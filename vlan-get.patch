diff --git a/configure.ac b/configure.ac
index 66e7a95..21a859a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 #                                               -*- Autoconf -*-
 # Process this file with autoconf to produce a configure script.
 AC_PREREQ([2.69])
-AC_INIT([opx-nas-interface], [5.17.0], [ops-dev@lists.openswitch.net])
+AC_INIT([opx-nas-interface], [5.18.0], [ops-dev@lists.openswitch.net])
 AM_INIT_AUTOMAKE([foreign subdir-objects])
 AC_CONFIG_SRCDIR([.])
 AC_CONFIG_HEADERS([config.h])
diff --git a/debian/changelog b/debian/changelog
index 4bfc80f..c1d727f 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,9 @@
+opx-nas-interface (5.18.0) unstable; urgency=medium
+  
+  * Update: VLAN interface-state get-handler
+
+ -- Dell EMC <ops-dev@lists.openswitch.net>  Thu, 28 Jun 2018 17:17:56 -0800
+
 opx-nas-interface (5.17.0) unstable; urgency=medium
 
   * Update: VLAN filtering support
@@ -17,7 +23,7 @@ opx-nas-interface (5.17.0) unstable; urgency=medium
   * Bugfix: Set NPU port correctly for a member in a bridge for 
             mapped/unmapped events/
 
- -- Dell EMC <ops-dev@lists.openswitch.net>  Thu, 26 Apr 2018 17:17:56 -0800
+ -- Dell EMC <ops-dev@lists.openswitch.net>  Mon, 18 Jun 2018 17:17:56 -0800
  
 opx-nas-interface (5.10.1+opx15) unstable; urgency=medium
 
diff --git a/inc/opx/nas_int_bridge.h b/inc/opx/nas_int_bridge.h
index e53c0e6..ada9ade 100644
--- a/inc/opx/nas_int_bridge.h
+++ b/inc/opx/nas_int_bridge.h
@@ -39,12 +39,17 @@ extern "C" {
 
 #include "nas_int_list.h"
 #define SYSTEM_DEFAULT_VLAN 1
+
+typedef std::unordered_map<hal_ifindex_t,bool> nas_vlan_port_oper_status_t;
+
 typedef struct nas_bridge_s{
-    hal_ifindex_t ifindex;      //Kernel ifindex of the bridge
-    hal_vlan_id_t vlan_id;      //One bridge maps to one Vlan ID in the NPU
     char mac_addr[MAC_STRING_SZ];  //MAC address of this bridge // TODO to be Deprecated
     char name[HAL_IF_NAME_SZ]; //Just store it for now.
+    hal_ifindex_t ifindex;      //Kernel ifindex of the bridge
+    hal_vlan_id_t vlan_id;      //One bridge maps to one Vlan ID in the NPU
     IF_INTERFACES_STATE_INTERFACE_ADMIN_STATUS_t admin_status;
+    IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_status; // operation status of interface
+    nas_vlan_port_oper_status_t oper_list; //list of memberports operation states
     bool learning_disable;     //learning disable state.
     unsigned int int_sub_type; //vlan type (mgmt/data)
     nas_list_t untagged_list; //untagged vlan ports in this bridge
@@ -136,6 +141,12 @@ bool nas_handle_vid_to_br(hal_vlan_id_t vlan_id, hal_ifindex_t if_index);
 
 t_std_error nas_cleanup_bridge(nas_bridge_t *p_bridge_node);
 
+void nas_port_update_vlan_oper_state_cb(npu_id_t npu, npu_port_t port,
+                        IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t status);
+void nas_lag_update_vlan_oper_state_cb(hal_ifindex_t if_idx,
+                        IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_state);
+
+void nas_update_port_to_vlans_map(const hal_ifindex_t port_idx, const hal_ifindex_t vlan_idx, bool add);
 #ifdef __cplusplus
 }
 #endif
diff --git a/inc/opx/nas_int_lag_api.h b/inc/opx/nas_int_lag_api.h
index 210bcc2..3203f9e 100644
--- a/inc/opx/nas_int_lag_api.h
+++ b/inc/opx/nas_int_lag_api.h
@@ -164,6 +164,8 @@ t_std_error nas_lag_set_mac(hal_ifindex_t index,const char *lag_mac);
 t_std_error nas_lag_set_admin_status(hal_ifindex_t index, bool enable);
 t_std_error nas_lag_block_port(nas_lag_master_info_t  *p_lag_info ,hal_ifindex_t slave_ifindex,bool block_state);
 t_std_error nas_lag_get_port_mode(hal_ifindex_t slave_ifindex,bool& block_state);
+t_std_error nas_lag_get_admin_status(hal_ifindex_t index, bool enable);
+t_std_error nas_lag_get_oper_status(hal_ifindex_t index, bool enable);
 hal_ifindex_t nas_get_master_idx(hal_ifindex_t ifindex);
 void nas_cps_handle_mac_set (const char *lag_name, hal_ifindex_t lag_index);
 
@@ -173,5 +175,10 @@ cps_api_return_code_t lag_object_publish(nas_lag_master_info_t *nas_lag_entry,ha
 t_std_error nas_lag_get_ndi_lag_id(hal_ifindex_t lag_index, ndi_obj_id_t *ndi_lag_id);
 
 
+typedef void (*lag_oper_state_handler_t) (hal_ifindex_t if_idx, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_state);
+
+void nas_lag_oper_state_register_cb(lag_oper_state_handler_t oper_state_cb);
+void nas_lag_update_master_oper_state(nas_lag_master_info_t *nas_lag_entry, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_state);
+
 #endif /* NAS_INTF_LAG_API_H__ */
 
diff --git a/inc/opx/nas_int_vlan.h b/inc/opx/nas_int_vlan.h
index 24e318c..be96e13 100644
--- a/inc/opx/nas_int_vlan.h
+++ b/inc/opx/nas_int_vlan.h
@@ -124,9 +124,9 @@ t_std_error nas_vlan_get_all_info(cps_api_object_list_t list);
  *
  * @return : Standard error code
  */
-t_std_error nas_get_vlan_intf(const char *if_name, hal_ifindex_t ifindex, cps_api_object_list_t list);
+t_std_error nas_get_vlan_intf(const char *if_name, hal_ifindex_t ifindex, cps_api_object_list_t list, bool get_state);
 
-t_std_error nas_get_vlan_intf_from_vid(hal_vlan_id_t vid, cps_api_object_list_t list);
+t_std_error nas_get_vlan_intf_from_vid(hal_vlan_id_t vid, cps_api_object_list_t list, bool get_state);
 t_std_error nas_register_vlan_intf(nas_bridge_t *p_bridge, hal_intf_reg_op_type_t op);
 cps_api_return_code_t nas_publish_vlan_object(nas_bridge_t *p_bridge_node, cps_api_operation_types_t op);
 
diff --git a/src/lag/nas_int_lag_api.cpp b/src/lag/nas_int_lag_api.cpp
index bc2fe03..99ce7c9 100644
--- a/src/lag/nas_int_lag_api.cpp
+++ b/src/lag/nas_int_lag_api.cpp
@@ -31,6 +31,7 @@
 #include "dell-base-if.h"
 #include "dell-interface.h"
 #include "nas_ndi_port.h"
+#include <set>
 
 
 
@@ -70,6 +71,21 @@ std_mutex_type_t *nas_lag_mutex_lock()
     return &lag_lock;
 }
 
+auto lag_oper_state_handlers = new std::set <lag_oper_state_handler_t>;
+
+void nas_lag_oper_state_register_cb(lag_oper_state_handler_t oper_state_cb) {
+    if (oper_state_cb != NULL) {
+        lag_oper_state_handlers->insert(oper_state_cb);
+    }
+}
+
+void nas_lag_update_master_oper_state(nas_lag_master_info_t *nas_lag_entry, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_state) {
+    /* use callbacks to update the operation-state of the interface this lag is a member of (ie: vlan) */
+    for (auto cb_func : *lag_oper_state_handlers) {
+        cb_func(nas_lag_entry->ifindex, oper_state);
+    }
+}
+
 t_std_error nas_add_slave_node(hal_ifindex_t lag_master_id,hal_ifindex_t ifindex,
         ndi_obj_id_t ndi_lag_member_id){
 
@@ -246,6 +262,10 @@ t_std_error nas_lag_member_add(hal_ifindex_t lag_master_id,hal_ifindex_t ifindex
     if ((ndi_port_link_state_get(intf_ctrl.npu_id,intf_ctrl.port_id, &state))
                                    == STD_ERR_OK) {
         nas_lag_entry->port_oper_list[ifindex]= (state.oper_status ==ndi_port_OPER_UP) ? true : false;
+        if (!nas_lag_entry->oper_status && nas_lag_entry->port_oper_list[ifindex]) {
+            nas_lag_entry->oper_status = true;
+            nas_lag_update_master_oper_state(nas_lag_entry, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP);
+        }
     }
 
     return ret;
@@ -476,7 +496,7 @@ t_std_error nas_lag_set_admin_status(hal_ifindex_t index, bool enable)
 
     if(nas_lag_entry == NULL){
         EV_LOGGING(INTERFACE, ERR, "NAS-LAG",
-                   "Lag intf %d Err in set_admin_statue", index);
+                   "Lag intf %d Err in %s", index, __FUNCTION__);
         return STD_ERR(INTERFACE,FAIL, 0);
     }
 
@@ -491,6 +511,44 @@ t_std_error nas_lag_set_admin_status(hal_ifindex_t index, bool enable)
     return STD_ERR_OK;
 }
 
+t_std_error nas_lag_get_admin_status(hal_ifindex_t index, bool &admin_status)
+{
+    nas_lag_master_info_t *nas_lag_entry = NULL;
+
+    EV_LOGGING(INTERFACE, INFO, "NAS-LAG", "Lag intf %d for set_admin_status",
+               index);
+
+    nas_lag_entry = nas_get_lag_node(index);
+
+    if(nas_lag_entry == NULL){
+        EV_LOGGING(INTERFACE, ERR, "NAS-LAG",
+                   "Lag intf %d Err in %s", index, __FUNCTION__);
+        return STD_ERR(INTERFACE,FAIL, 0);
+    }
+
+    admin_status = nas_lag_entry->admin_status;
+    return STD_ERR_OK;
+}
+
+t_std_error nas_lag_get_oper_status(hal_ifindex_t index, bool &oper_status)
+{
+    nas_lag_master_info_t *nas_lag_entry = NULL;
+
+    EV_LOGGING(INTERFACE, INFO, "NAS-LAG", "Lag intf %d for set_admin_status",
+               index);
+
+    nas_lag_entry = nas_get_lag_node(index);
+
+    if(nas_lag_entry == NULL){
+        EV_LOGGING(INTERFACE, ERR, "NAS-LAG",
+                   "Lag intf %d Err in %s", index, __FUNCTION__);
+        return STD_ERR(INTERFACE,FAIL, 0);
+    }
+
+    oper_status = nas_lag_entry->oper_status;
+    return STD_ERR_OK;
+}
+
 t_std_error nas_lag_block_port(nas_lag_master_info_t  *nas_lag_entry ,hal_ifindex_t slave_ifindex,
         bool block_state)
 {
diff --git a/src/lag/nas_int_lag_cps.cpp b/src/lag/nas_int_lag_cps.cpp
index 9ab42fd..ae78381 100644
--- a/src/lag/nas_int_lag_cps.cpp
+++ b/src/lag/nas_int_lag_cps.cpp
@@ -1223,6 +1223,10 @@ void nas_lag_port_oper_state_cb(npu_id_t npu, npu_port_t port, IF_INTERFACES_STA
          (status == IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP) ) {
 
          block_status = false;
+         if (!nas_lag_entry->oper_status) {
+            nas_lag_update_master_oper_state(nas_lag_entry, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP);
+            nas_lag_entry->oper_status = true;
+         }
     }
 
     if (nas_lag_block_port(nas_lag_entry, slave_index, block_status) != STD_ERR_OK){
@@ -1241,6 +1245,8 @@ void nas_lag_port_oper_state_cb(npu_id_t npu, npu_port_t port, IF_INTERFACES_STA
         }
 
         if(publish_oper_down){
+            nas_lag_entry->oper_status = false;
+            nas_lag_update_master_oper_state(nas_lag_entry, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN);
             lag_state_object_publish(nas_lag_entry,false);
         }
     }
diff --git a/src/vlan/nas_int_bridge.cpp b/src/vlan/nas_int_bridge.cpp
index baa3b65..d564c28 100644
--- a/src/vlan/nas_int_bridge.cpp
+++ b/src/vlan/nas_int_bridge.cpp
@@ -35,6 +35,8 @@
 #include <string.h>
 
 static auto bridge_list = new bridge_list_t;
+static std::unordered_map<hal_ifindex_t,std::unordered_set<hal_ifindex_t>> nas_port_to_vlans;
+
 typedef std::unordered_map <hal_vlan_id_t, hal_ifindex_t>  vlanid_to_bridge_t;
 vlanid_to_bridge_t vid_to_bridge;
 
@@ -101,6 +103,95 @@ void nas_bridge_unlock(void)
     std_mutex_unlock (&br_lock);
 }
 
+void nas_update_port_to_vlans_map(const hal_ifindex_t port_idx, const hal_ifindex_t vlan_idx, bool add) {
+    if (add) {
+        nas_port_to_vlans[port_idx].insert(vlan_idx);
+    } else {
+        if (nas_port_to_vlans.find(port_idx) != nas_port_to_vlans.end()) {
+            if (nas_port_to_vlans[port_idx].size() == 1) {
+                nas_port_to_vlans.erase(port_idx);
+            } else {
+                nas_port_to_vlans[port_idx].erase(vlan_idx);
+            }
+        }
+    }
+
+    return;
+}
+
+void nas_lag_update_vlan_oper_state_cb(hal_ifindex_t lagif_idx,
+                        IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_status) {
+    nas_bridge_t *vlan_entry;
+
+    if (nas_port_to_vlans.find(lagif_idx) != nas_port_to_vlans.end()) {
+        for (auto vlan_index : nas_port_to_vlans[lagif_idx]) {
+            //nas_bridge_lock();
+            if ((vlan_entry = nas_get_bridge_node(vlan_index)) == NULL) {
+                return;
+            }
+
+            if (oper_status == IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP) {
+                vlan_entry->oper_list[lagif_idx] = true;
+                vlan_entry->oper_status = oper_status;
+            } else {
+                vlan_entry->oper_list[lagif_idx] = false;
+                vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN;
+                for (auto oper_status : vlan_entry->oper_list) {
+                    if (oper_status.second) {
+                        vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP;
+                        break;
+                    }
+                }
+            }
+            //nas_bridge_unlock();
+        }
+    }
+
+    return;
+}
+
+void nas_port_update_vlan_oper_state_cb(npu_id_t npu, npu_port_t port,
+                        IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_status) {
+    hal_ifindex_t port_index;
+    nas_bridge_t *vlan_entry;
+    ndi_port_t ndi_port;
+    ndi_port.npu_id = npu;
+    ndi_port.npu_port = port;
+
+    EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
+                      "LAG member port oper status processing");
+
+    if (nas_int_get_if_index_from_npu_port(&port_index, &ndi_port) != STD_ERR_OK) {
+        return;
+    }
+
+    if (nas_port_to_vlans.find(port_index) != nas_port_to_vlans.end()) {
+        for (auto vlan_index : nas_port_to_vlans[port_index]) {
+            //nas_bridge_lock();
+            if ((vlan_entry = nas_get_bridge_node(vlan_index)) == NULL) {
+                return;
+            }
+
+            if (oper_status == IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP) {
+                vlan_entry->oper_list[port_index] = true;
+                vlan_entry->oper_status = oper_status;
+            } else {
+                vlan_entry->oper_list[port_index] = false;
+                vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN;
+                for (auto oper_status : vlan_entry->oper_list) {
+                    if (oper_status.second) {
+                        vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP;
+                        break;
+                    }
+                }
+            }
+            //nas_bridge_unlock();
+        }
+    }
+
+    return;
+}
+
 nas_bridge_t *nas_get_bridge_node(hal_ifindex_t index)
 {
 
@@ -146,6 +237,8 @@ nas_bridge_t* nas_create_insert_bridge_node(hal_ifindex_t index, const char *nam
         EV_LOGGING(INTERFACE, INFO, "NAS-Br",
                     "Bridge intf %d created", index);
         node.ifindex = index;
+        node.oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN;
+        node.oper_list = nas_vlan_port_oper_status_t();
         safestrncpy(node.name, name, sizeof(node.name));
 
         bridge_list->insert({index,node});
diff --git a/src/vlan/nas_int_vlan.cpp b/src/vlan/nas_int_vlan.cpp
index dce8311..dcd2d37 100644
--- a/src/vlan/nas_int_vlan.cpp
+++ b/src/vlan/nas_int_vlan.cpp
@@ -22,6 +22,7 @@
 #include "nas_ndi_vlan.h"
 #include "nas_int_bridge.h"
 #include "nas_int_vlan.h"
+#include "nas_int_port.h"
 #include "event_log.h"
 #include "event_log_types.h"
 #include "nas_int_utils.h"
@@ -164,6 +165,11 @@ t_std_error nas_add_or_del_port_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
     ndi_port_list.port_count = 1;
     ndi_port_list.port_list =p_ndi_port;
     t_std_error rc = STD_ERR_OK;
+    nas_bridge_t *vlan_entry = nas_get_bridge_node_from_vid(vlan_id);
+
+    if (!vlan_entry) {
+        return (STD_ERR(INTERFACE,FAIL, 0));
+    }
 
     if (port_mode == NAS_PORT_TAGGED) {
         tag_list = &ndi_port_list;
@@ -171,6 +177,7 @@ t_std_error nas_add_or_del_port_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
     else {
         untag_list = &ndi_port_list;
     }
+
     EV_LOGGING(INTERFACE, INFO, "NAS-Vlan",
                 "Updating VLAN member: %s %s port <%d %d> %s VLAN %d", (add_port ? "add" : "delete"),
                 p_ndi_port->npu_id, p_ndi_port->npu_port, (add_port ? "from" : "to"),
@@ -203,6 +210,43 @@ t_std_error nas_add_or_del_port_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
         }
     }
 
+    ndi_intf_link_state_t link_state;
+    IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t oper_state;
+    rc = ndi_port_link_state_get(p_ndi_port->npu_id, p_ndi_port->npu_port, &link_state);
+    hal_ifindex_t port_idx;
+
+    if (nas_int_get_if_index_from_npu_port(&port_idx, p_ndi_port) != STD_ERR_OK) {
+        return (STD_ERR(INTERFACE,FAIL, 0));
+    }
+
+    if (rc != STD_ERR_OK) {
+        return (STD_ERR(INTERFACE,FAIL, 0));
+    }
+
+    if (add_port) {
+        /* action for adding a port */
+        oper_state = ndi_to_cps_oper_type(link_state.oper_status);
+        if (oper_state == IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP) {
+            (vlan_entry->oper_list)[port_idx] = true;
+            vlan_entry->oper_status = oper_state;
+        } else {
+            (vlan_entry->oper_list)[port_idx] = false;
+        }
+        nas_update_port_to_vlans_map(port_idx, vlan_entry->ifindex, true);
+
+    } else {
+        /* action for deleting port */
+        (vlan_entry->oper_list).erase(port_idx);
+        vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN;
+        for (auto oper_status: vlan_entry->oper_list) {
+            if (oper_status.second) {
+                vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP;
+                break;
+            }
+        }
+        nas_update_port_to_vlans_map(port_idx, vlan_entry->ifindex, false);
+    }
+
     return STD_ERR_OK;
 
 }
@@ -826,7 +870,7 @@ void nas_pack_vlan_if(cps_api_object_t obj, nas_bridge_t *p_bridge)
 }
 
 
-t_std_error nas_get_vlan_intf(const char *if_name, hal_ifindex_t ifindex, cps_api_object_list_t list)
+t_std_error nas_get_vlan_intf(const char *if_name, hal_ifindex_t ifindex, cps_api_object_list_t list, bool get_state)
 {
     nas_bridge_t *p_bridge = NULL;
 
@@ -849,10 +893,15 @@ t_std_error nas_get_vlan_intf(const char *if_name, hal_ifindex_t ifindex, cps_ap
         return(STD_ERR(INTERFACE, FAIL, 0));
     }
     nas_pack_vlan_if(object, p_bridge);
+    if (get_state) {
+        cps_api_object_attr_add_u32(object, IF_INTERFACES_STATE_INTERFACE_ADMIN_STATUS, p_bridge->admin_status);
+        cps_api_object_attr_add_u32(object, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS, p_bridge->oper_status);
+    }
+
     return STD_ERR_OK;
 }
 
-t_std_error nas_get_vlan_intf_from_vid(hal_vlan_id_t vid, cps_api_object_list_t list)
+t_std_error nas_get_vlan_intf_from_vid(hal_vlan_id_t vid, cps_api_object_list_t list, bool get_state)
 {
     nas_bridge_t *p_bridge = NULL;
 
@@ -871,6 +920,10 @@ t_std_error nas_get_vlan_intf_from_vid(hal_vlan_id_t vid, cps_api_object_list_t
         return(STD_ERR(INTERFACE, FAIL, 0));
     }
     nas_pack_vlan_if(object, p_bridge);
+    if (get_state) {
+        cps_api_object_attr_add_u32(object, IF_INTERFACES_STATE_INTERFACE_ADMIN_STATUS, p_bridge->admin_status);
+        cps_api_object_attr_add_u32(object, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS, p_bridge->oper_status);
+    }
     return STD_ERR_OK;
 }
 
diff --git a/src/vlan/nas_vlan_cps.cpp b/src/vlan/nas_vlan_cps.cpp
index 3482ff9..5e49c0d 100644
--- a/src/vlan/nas_vlan_cps.cpp
+++ b/src/vlan/nas_vlan_cps.cpp
@@ -41,6 +41,7 @@
 #include "hal_interface_common.h"
 #include "nas_int_com_utils.h"
 #include "nas_if_utils.h"
+#include "nas_int_lag_api.h"
 #include "std_config_node.h"
 #include "std_mutex_lock.h"
 #include "cps_api_object_tools.h"
@@ -65,25 +66,40 @@ static t_std_error nas_cps_del_port_from_vlan(nas_bridge_t *p_bridge, nas_list_n
 t_std_error nas_cps_cleanup_vlan_lists(hal_vlan_id_t vlan_id, nas_list_t *p_link_node_list);
 static t_std_error nas_cps_add_port_to_vlan(nas_bridge_t *p_bridge, hal_ifindex_t port_idx, nas_port_mode_t port_mode);
 
+static inline cps_api_return_code_t nas_vlan_get_oper_status(cps_api_object_t obj, nas_bridge_t *p_bridge)
+{
+     cps_api_object_attr_add_u32(obj, IF_INTERFACES_STATE_INTERFACE_OPER_STATUS, p_bridge->oper_status);
+     return cps_api_ret_code_OK;
+}
 
 static inline cps_api_return_code_t nas_vlan_get_admin_status(cps_api_object_t obj, nas_bridge_t *p_bridge)
 {
+     cps_api_object_attr_add_u32(obj, IF_INTERFACES_STATE_INTERFACE_ADMIN_STATUS, p_bridge->admin_status);
+     return cps_api_ret_code_OK;
+}
+
+static inline cps_api_return_code_t nas_vlan_get_intf_status(cps_api_object_t obj, nas_bridge_t *p_bridge)
+{
+    /* Interface enabled/disabled is same as admin-status up/down */
      cps_api_object_attr_add_u32(obj, IF_INTERFACES_INTERFACE_ENABLED,
                  (p_bridge->admin_status == IF_INTERFACES_STATE_INTERFACE_ADMIN_STATUS_UP) ? true: false);
      return cps_api_ret_code_OK;
 }
+
 static inline cps_api_return_code_t nas_vlan_get_learning_mode(cps_api_object_t obj, nas_bridge_t *p_bridge)
 {
      cps_api_object_attr_add_u32(obj, DELL_IF_IF_INTERFACES_INTERFACE_LEARNING_MODE,
                                         p_bridge->learning_disable);
      return cps_api_ret_code_OK;
 }
+
 static inline cps_api_return_code_t nas_vlan_get_mac(cps_api_object_t obj, nas_bridge_t *p_bridge)
 {
      cps_api_object_attr_add(obj, DELL_IF_IF_INTERFACES_INTERFACE_PHYS_ADDRESS,
                                         p_bridge->mac_addr, sizeof(p_bridge->mac_addr));
      return cps_api_ret_code_OK;
 }
+
 static inline cps_api_return_code_t nas_vlan_get_mtu(cps_api_object_t obj, nas_bridge_t *p_bridge)
 {
     if(p_bridge->mtu){
@@ -148,7 +164,6 @@ static bool nas_vlan_process_port_association(hal_ifindex_t ifindex, npu_id_t np
     return true;
 }
 
-
 static bool nas_vlan_if_set_handler(cps_api_object_t obj, void *context)
 {
     EV_LOGGING(INTERFACE,DEBUG,"NAS-VLAN-MAP","Got Interface event");
@@ -182,8 +197,9 @@ static bool nas_vlan_if_set_handler(cps_api_object_t obj, void *context)
 }
 
 
-static cps_api_return_code_t nas_vlan_set_admin_status(cps_api_object_t obj, nas_bridge_t *p_bridge)
+static cps_api_return_code_t nas_vlan_set_intf_status(cps_api_object_t obj, nas_bridge_t *p_bridge)
 {
+    /* Interface enabled/disabled is same as admin-status up/down */
 
     cps_api_object_attr_t attr = cps_api_object_attr_get(obj, IF_INTERFACES_INTERFACE_ENABLED);
 
@@ -340,7 +356,7 @@ cps_api_return_code_t nas_cps_set_vlan_mtu(cps_api_object_t obj, nas_bridge_t *p
 static auto set_vlan_attr = new std::unordered_map<cps_api_attr_id_t,
     cps_api_return_code_t (*)(cps_api_object_t, nas_bridge_t *)>
 {
-    { IF_INTERFACES_INTERFACE_ENABLED, nas_vlan_set_admin_status },
+    { IF_INTERFACES_INTERFACE_ENABLED, nas_vlan_set_intf_status },
     { DELL_IF_IF_INTERFACES_INTERFACE_LEARNING_MODE, nas_cps_set_vlan_learning_mode },
     { DELL_IF_IF_INTERFACES_INTERFACE_PHYS_ADDRESS, nas_cps_set_vlan_mac},
     { DELL_IF_IF_INTERFACES_INTERFACE_MTU, nas_cps_set_vlan_mtu}
@@ -349,7 +365,7 @@ static auto set_vlan_attr = new std::unordered_map<cps_api_attr_id_t,
 static auto get_vlan_attr = new  std::unordered_map<cps_api_attr_id_t,
     cps_api_return_code_t (*)(cps_api_object_t, nas_bridge_t *)>
 {
-    { IF_INTERFACES_INTERFACE_ENABLED, nas_vlan_get_admin_status },
+    { IF_INTERFACES_INTERFACE_ENABLED, nas_vlan_get_intf_status },
     { DELL_IF_IF_INTERFACES_INTERFACE_LEARNING_MODE, nas_vlan_get_learning_mode },
     { DELL_IF_IF_INTERFACES_INTERFACE_PHYS_ADDRESS, nas_vlan_get_mac},
     { DELL_IF_IF_INTERFACES_INTERFACE_MTU, nas_vlan_get_mtu}
@@ -1004,13 +1020,13 @@ static cps_api_return_code_t nas_process_cps_vlan_get(void * context,
               hal_ifindex_t index = 0;
               if(name_attr) if_name = (char *)cps_api_object_attr_data_bin(name_attr);
               if(if_index_attr) index = cps_api_object_attr_data_u32(if_index_attr);
-              if (nas_get_vlan_intf(if_name, index, param->list) != STD_ERR_OK) {
+              if (nas_get_vlan_intf(if_name, index, param->list, false) != STD_ERR_OK) {
                   nas_bridge_unlock();
                   return cps_api_ret_code_ERR;
               }
           } else if (vlan_id_attr != NULL) {
               hal_vlan_id_t vid = cps_api_object_attr_data_u32(vlan_id_attr);
-              if (nas_get_vlan_intf_from_vid(vid, param->list) != STD_ERR_OK) {
+              if (nas_get_vlan_intf_from_vid(vid, param->list, false) != STD_ERR_OK) {
                   nas_bridge_unlock();
                   return cps_api_ret_code_ERR;
               }
@@ -1026,6 +1042,58 @@ static cps_api_return_code_t nas_process_cps_vlan_get(void * context,
     return cps_api_ret_code_OK;
 }
 
+static cps_api_return_code_t nas_process_cps_vlan_state_set(void *context, cps_api_transaction_params_t *param, size_t ix)
+{
+    return cps_api_ret_code_ERR;
+}
+
+static cps_api_return_code_t nas_process_cps_vlan_state_get(void * context,
+                                                      cps_api_get_params_t *param,
+                                                      size_t ix)
+{
+    size_t iix = 0;
+    size_t mx = cps_api_object_list_size(param->list);
+
+    EV_LOGGING(INTERFACE, DEBUG, "NAS-Vlan",
+            "nas_process_cps_vlan_get");
+    nas_bridge_lock();
+    do {
+         cps_api_object_t filter = cps_api_object_list_get(param->filters, ix);
+         cps_api_object_attr_t name_attr = cps_api_get_key_data(filter,
+                                            IF_INTERFACES_STATE_INTERFACE_NAME);
+         cps_api_object_attr_t if_index_attr = cps_api_get_key_data(filter,
+                                            DELL_BASE_IF_CMN_IF_INTERFACES_INTERFACE_IF_INDEX);
+         cps_api_object_attr_t vlan_id_attr = cps_api_object_attr_get(filter,
+                                    BASE_IF_VLAN_IF_INTERFACES_INTERFACE_ID);
+
+         if (name_attr != NULL || if_index_attr != NULL) {
+              const char *if_name = NULL;
+              hal_ifindex_t index = 0;
+              if(name_attr) if_name = (char *)cps_api_object_attr_data_bin(name_attr);
+              if(if_index_attr) index = cps_api_object_attr_data_u32(if_index_attr);
+              if (nas_get_vlan_intf(if_name, index, param->list, true) != STD_ERR_OK) {
+                  nas_bridge_unlock();
+                  return cps_api_ret_code_ERR;
+              }
+          } else if (vlan_id_attr != NULL) {
+              hal_vlan_id_t vid = cps_api_object_attr_data_u32(vlan_id_attr);
+              if (nas_get_vlan_intf_from_vid(vid, param->list, true) != STD_ERR_OK) {
+                  nas_bridge_unlock();
+                  return cps_api_ret_code_ERR;
+              }
+          }
+          else {
+              nas_vlan_get_all_info(param->list);
+          }
+
+         ++iix;
+    }while (iix < mx);
+
+    nas_bridge_unlock();
+    return cps_api_ret_code_OK;
+}
+
+
 static cps_api_return_code_t nas_if_handle_global_set (void * context,
                                                        cps_api_transaction_params_t *param,
                                                       size_t ix) {
@@ -1080,6 +1148,15 @@ t_std_error nas_cps_vlan_init(cps_api_operation_handle_t handle) {
         return STD_ERR(INTERFACE,FAIL,0);
     }
 
+    if (intf_obj_handler_registration(obj_INTF_STATE, nas_int_type_VLAN,
+                nas_process_cps_vlan_state_get, nas_process_cps_vlan_state_set) != STD_ERR_OK) {
+        EV_LOGGING(INTERFACE, ERR, "NAS-VLAN-INIT", "Failed to register VLAN interface state CPS handler");
+        return STD_ERR(INTERFACE,FAIL,0);
+    }
+
+    nas_int_oper_state_register_cb(nas_port_update_vlan_oper_state_cb);
+    nas_lag_oper_state_register_cb(nas_lag_update_vlan_oper_state_cb);
+
     cps_api_event_reg_t reg;
     cps_api_key_t key;
 
@@ -1292,7 +1369,6 @@ static t_std_error nas_cps_del_port_from_vlan(nas_bridge_t *p_bridge, nas_list_n
         }
     }
 
-
     if(!nas_intf_cleanup_l2mc_config(p_link_node->ifindex,  p_bridge->vlan_id)) {
         EV_LOGGING(INTERFACE, ERR, "NAS-Vlan",
                "Error cleaning L2MC membership for interface %d", p_link_node->ifindex);
diff --git a/src/vlan/nas_vlan_lag_api.cpp b/src/vlan/nas_vlan_lag_api.cpp
index 6423f39..7b1d337 100644
--- a/src/vlan/nas_vlan_lag_api.cpp
+++ b/src/vlan/nas_vlan_lag_api.cpp
@@ -61,6 +61,12 @@ t_std_error nas_add_or_del_lag_in_vlan(hal_ifindex_t lag_index, hal_vlan_id_t vl
     ndi_obj_id_t ndi_lag_id;
     t_std_error ret = STD_ERR_OK;
     size_t tag_cnt =0, untag_cnt=0;
+    nas_bridge_t *vlan_entry = nas_get_bridge_node_from_vid(vlan_id);
+    nas_lag_master_info_t *nas_lag_entry = nas_get_lag_node(lag_index);
+
+    if (!vlan_entry || !nas_lag_entry) {
+        return (STD_ERR(INTERFACE,FAIL, 0));
+    }
 
     (port_mode == NAS_PORT_TAGGED) ?  (tagged_lag = &ndi_lag_id, tag_cnt=1) :
                                       (untagged_lag = &ndi_lag_id,untag_cnt=1);
@@ -70,9 +76,9 @@ t_std_error nas_add_or_del_lag_in_vlan(hal_ifindex_t lag_index, hal_vlan_id_t vl
             lag_index, add_flag, vlan_id);
 
     if ((ret = nas_lag_get_ndi_lag_id (lag_index, &ndi_lag_id)) != STD_ERR_OK) {
-    EV_LOGGING(INTERFACE, INFO, "NAS-VLAN", "Error finding NDI LAG ID %d  %d %d",
-                         lag_index, vlan_id, add_flag);
-    return ret;
+        EV_LOGGING(INTERFACE, INFO, "NAS-VLAN", "Error finding NDI LAG ID %d  %d %d",
+                             lag_index, vlan_id, add_flag);
+        return ret;
     }
 
     if (add_flag) {
@@ -80,8 +86,25 @@ t_std_error nas_add_or_del_lag_in_vlan(hal_ifindex_t lag_index, hal_vlan_id_t vl
         if (port_mode == NAS_PORT_UNTAGGED) {
             ndi_set_lag_pvid(0, ndi_lag_id, vlan_id);
         }
+
+        if (nas_lag_entry->oper_status) {
+           (vlan_entry->oper_list)[lag_index] = true;
+           vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP;
+        } else {
+           (vlan_entry->oper_list)[lag_index] = true;
+        }
+        nas_update_port_to_vlans_map(lag_index, vlan_entry->ifindex, true);
     } else {
         ret = ndi_del_lag_from_vlan(0, vlan_id, tagged_lag, tag_cnt, untagged_lag, untag_cnt);
+        (vlan_entry->oper_list).erase(lag_index);
+        vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN;
+        for (auto oper_status: vlan_entry->oper_list) {
+            if (oper_status.second) {
+                vlan_entry->oper_status = IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_UP;
+                break;
+            }
+        }
+        nas_update_port_to_vlans_map(lag_index, vlan_entry->ifindex, false);
     }
     /* TODO rollback case */
 
