diff --git a/configure.ac b/configure.ac
index 66e7a95..5d6f766 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,7 +1,7 @@
 #                                               -*- Autoconf -*-
 # Process this file with autoconf to produce a configure script.
 AC_PREREQ([2.69])
-AC_INIT([opx-nas-interface], [5.17.0], [ops-dev@lists.openswitch.net])
+AC_INIT([opx-nas-interface], [5.17.1], [ops-dev@lists.openswitch.net])
 AM_INIT_AUTOMAKE([foreign subdir-objects])
 AC_CONFIG_SRCDIR([.])
 AC_CONFIG_HEADERS([config.h])
diff --git a/debian/changelog b/debian/changelog
index 4bfc80f..bdc32c1 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,3 +1,17 @@
+opx-nas-interface (5.17.1) unstable; urgency=medium
+
+  * Bugfix: Sending sequential hwport offset value from port group object to PAS
+            for setting media transciever
+  * Bugfix: Handle the mode change for lag blocked port in netlink handler
+  * Bugfix: Get the port mode before adding port to LAG in kernel
+  * Bugfix: Remove the publish of oper state just after connecting interface to NPU port
+  * Bugfix: Using steady clock for providing independent timestamps
+  * Bugfix: Fix MAC address change when adding memberport to LAG
+  * Feature: Add interface name and ifindex to the output list when querying for stats
+  * Feature: Adding QSA support for 1G SFP media
+
+ -- Dell EMC <ops-dev@lists.openswitch.net>  Thu, 28 Jun 2018 17:17:56 -0800
+
 opx-nas-interface (5.17.0) unstable; urgency=medium
 
   * Update: VLAN filtering support
@@ -17,7 +31,7 @@ opx-nas-interface (5.17.0) unstable; urgency=medium
   * Bugfix: Set NPU port correctly for a member in a bridge for 
             mapped/unmapped events/
 
- -- Dell EMC <ops-dev@lists.openswitch.net>  Thu, 26 Apr 2018 17:17:56 -0800
+ -- Dell EMC <ops-dev@lists.openswitch.net>  Mon, 18 Jun 2018 17:17:56 -0800
  
 opx-nas-interface (5.10.1+opx15) unstable; urgency=medium
 
diff --git a/inc/opx/nas_int_vlan.h b/inc/opx/nas_int_vlan.h
index 24e318c..ec6d2ed 100644
--- a/inc/opx/nas_int_vlan.h
+++ b/inc/opx/nas_int_vlan.h
@@ -132,7 +132,7 @@ cps_api_return_code_t nas_publish_vlan_object(nas_bridge_t *p_bridge_node, cps_a
 
 t_std_error nas_add_or_del_port_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
                                         ndi_port_t *p_ndi_port, nas_port_mode_t port_mode,
-                                        bool add_port);
+                                        bool add_port, hal_ifindex_t ifindex);
 
 t_std_error nas_cps_add_port_to_os(hal_ifindex_t br_index, hal_vlan_id_t vlan_id,
                                    nas_port_mode_t port_mode, hal_ifindex_t port_idx,uint32_t mtu,
diff --git a/scripts/bin/base_nas_front_panel_ports.py b/scripts/bin/base_nas_front_panel_ports.py
index 9ce1458..88e361b 100755
--- a/scripts/bin/base_nas_front_panel_ports.py
+++ b/scripts/bin/base_nas_front_panel_ports.py
@@ -162,7 +162,7 @@ def _set_speed(speed, config, obj):
             return False
     config.set_speed(speed)
     if speed == _yang_auto_speed:
-        if intf_phy_mode == nas_comm.get_value(nas_comm.yang_phy_mode, 'fc') or breakout_mode == _yang_breakout_1x1 or breakout_mode == _yang_breakout_4x4:
+        if intf_phy_mode == nas_comm.get_value(nas_comm.yang_phy_mode, 'fc') or breakout_mode == _yang_breakout_1x1 or breakout_mode == _yang_breakout_4x4 or media.is_sfp_media_type(config.get_media_type()):
             # TODO default speed in breakout mode is not supported  yet
             # TODO it may cause issue in port group ports. Verify the usecases.
             _add_default_speed(config, obj)
diff --git a/scripts/bin/base_nas_monitor_phy_media.py b/scripts/bin/base_nas_monitor_phy_media.py
index 64fed4d..c0e100a 100755
--- a/scripts/bin/base_nas_monitor_phy_media.py
+++ b/scripts/bin/base_nas_monitor_phy_media.py
@@ -58,7 +58,12 @@ def set_media_transceiver(interface_obj):
     #
     for hwport in hwport_list:
         fp_details = fp.find_port_by_hwport(npu, hwport)
-        _lane = fp_details.lane
+        if fp_details.port_group_id is None:
+            _lane = fp_details.lane
+        else:
+            pg_list = fp.get_port_group_list()
+            pg_obj = pg_list[fp_details.port_group_id]
+            _lane = pg_obj.get_lane(hwport)
         media.media_transceiver_set(1, fp_details.media_id, _lane, enable)
 
 def set_interface_media_speed(interface_obj, speed=None):
diff --git a/scripts/bin/cps_config_lag.py b/scripts/bin/cps_config_lag.py
index 42bbeb6..31da5ad 100755
--- a/scripts/bin/cps_config_lag.py
+++ b/scripts/bin/cps_config_lag.py
@@ -52,7 +52,7 @@ def usage():
     ''' This is the Usage Method '''
 
     print '<cps_config_lag:- Lag operations >'
-    print '\t\t cps_config_lag.py  --create --lname <lagname>'
+    print '\t\t cps_config_lag.py  --create --lname <lagname> [--port <port_list> [--frwd <yes/no>]'
     print '\t\t cps_config_lag.py  --delete --lname <lagname>'
     print '\t\t cps_config_lag.py  --add --lname <lagname> --port <port_list>'
     print '\t\t cps_config_lag.py  --remove --lname <lagname> --port <port_list>'
@@ -142,7 +142,24 @@ def main(argv):
 
 
     if choice == 'create' and lag_name != '':
-        nas_lag_op("create", {"if/interfaces/interface/name":lag_name})
+        cmd_data = {"if/interfaces/interface/name":lag_name}
+        nas_lag_op("create", cmd_data)
+        if port != '':
+            (obj, op)  = nas_lag_op("set", cmd_data, False)
+            port_list = port.split(",")
+            l = ["dell-if/if/interfaces/interface/member-ports","0","name"]
+            index = 0
+            for i in port_list:
+                l[1]=str(index)
+                index = index +1
+                obj.add_embed_attr(l,i)
+            nas_ut.get_cb_method(op)(obj)
+            if frwd_enable != '':
+                cmd_data["dell-if/if/interfaces/interface/member-ports/name"] = port_list
+                # Member ports are unblocked by default
+                if frwd_enable == 'no':
+                    cmd_data["base-if-lag/if/interfaces/interface/block-port-list"] = port_list
+                nas_lag_op("set", cmd_data)
 
     elif choice == 'mac-learn' and lag_name != '':
         nas_lag_op("set", {"if/interfaces/interface/name":lag_name,
@@ -158,7 +175,6 @@ def main(argv):
         nas_lag_op("get", {"if/interfaces/interface/name": lag_name})
 
     elif choice == 'set' and port != '' and lag_name != '' and frwd_enable != '':
-        ifindex_list = []
         port_list = port.split(",")
         nas_lag_op("set", {"if/interfaces/interface/name":lag_name,
                            "base-if-lag/if/interfaces/interface/unblock-port-list"
@@ -166,7 +182,7 @@ def main(argv):
                            "base-if-lag/if/interfaces/interface/block-port-list": port_list})
 
     elif (choice == 'add' or choice == 'remove') and port != '' and lag_name != '':
-        op = "create" if (choice == "add") else "delete"
+        op = "set" if (choice == "add") else "delete"
         (obj, op) = nas_lag_op(op,
                    {"if/interfaces/interface/name": lag_name},False)
         port_list = port.split(",")
diff --git a/scripts/bin/opx-show-transceivers b/scripts/bin/opx-show-transceivers
index 3fc6c2f..5fad18e 100755
--- a/scripts/bin/opx-show-transceivers
+++ b/scripts/bin/opx-show-transceivers
@@ -41,7 +41,6 @@ def display_media_inventory(verbose=False):
             # If port density > 1, use logical port list
             _port_density =  obj.get_attr_data('port-density')
             _sub_port_list = []
-            _qsa_str = ''
             if (_port_density > 0):
                 _sub_port_list = obj.get_attr_data('sub-port-id')
             else:
@@ -58,12 +57,7 @@ def display_media_inventory(verbose=False):
                 _serial_no = obj.get_attr_data('base-pas/media/serial-number')
                 _qualified = obj.get_attr_data('base-pas/media/qualified')
                 _disp_str_from_pas = obj.get_attr_data('base-pas/media/display-string')
-                _qsa_adap_type = obj.get_attr_data('base-pas/media/qsa-adapter')
 
-                if (_qsa_adap_type == PLATFORM_QSA_ADAPTER_QSA):
-                    _qsa_str = "(+QSA)"
-                elif (_qsa_adap_type == PLATFORM_QSA_ADAPTER_QSA28):
-                    _qsa_str = "(+QSA28)"
                 if (_disp_str_from_pas == ''):
                     _disp_str_from_pas = media.get_media_str(_media_type)
                 if _qualified == 1:
@@ -71,7 +65,7 @@ def display_media_inventory(verbose=False):
                 else:
                     _qualified = 'No'
             for _port in _sub_port_list:
-                print '%4s              %-30s%9s         %-18s    %-18s        %4s' % (str(_port), _disp_str_from_pas, _qsa_str, _vendor_pn, _serial_no, _qualified)
+                print '%4s              %-30s         %-18s    %-18s        %4s' % (str(_port), _disp_str_from_pas, _vendor_pn, _serial_no, _qualified)
             if verbose == True :
                 for _port in _sub_port_list:
                     display_media_info(_port)
diff --git a/scripts/lib/python/nas_front_panel_map.py b/scripts/lib/python/nas_front_panel_map.py
index 222310f..7d68e32 100755
--- a/scripts/lib/python/nas_front_panel_map.py
+++ b/scripts/lib/python/nas_front_panel_map.py
@@ -528,6 +528,7 @@ def find_port_by_hwport(npu, hwport):
     pd.port = p.id
     pd.hwport = hwport
     pd.media_id = p.media_id
+    pd.port_group_id = p.port_group_id
     return pd
 
 
@@ -619,6 +620,8 @@ class PortGroup(PortProfile):
         return self.fp_ports[:]
     def get_hw_ports(self):
         return self.hw_ports[:]
+    def get_lane(self,hwport):
+        return self.hw_ports.index(hwport)
 
     def apply_port_profile(self, port_profile):
         self.apply(port_profile)
diff --git a/scripts/lib/python/nas_phy_media.py b/scripts/lib/python/nas_phy_media.py
index af1b67c..f0de502 100755
--- a/scripts/lib/python/nas_phy_media.py
+++ b/scripts/lib/python/nas_phy_media.py
@@ -25,6 +25,29 @@ import bytearray_utils as ba
 
 _fp_port_key = cps.key_from_name('target','base-if-phy/front-panel-port')
 
+sfp_type_to_str = {
+    53: "SFP SX",
+    54: "SFP LX",
+    55: "SFP ZX",
+    56: "SFP CX",
+    57: "SFP DX",
+    58: "SFP T",
+    59: "SFP FX",
+    60: "SFP CWDM",
+    61: "SFP IR1",
+    62: "SFP LR1",
+    63: "SFP LR2",
+    64: "SFP BX10",
+    65: "SFP PX",
+    114: "SFP BX10 UP",
+    115: "SFP BX10 DOWN",
+    116: "SFP BX40 UP",
+    117: "SFP BX40 DOWN",
+    118: "SFP BX80 UP",
+    119: "SFP BX80 DOWN"
+}
+
+
 media_type_to_str = {
     0: "Not Applicable",
     1: "Not Present",
@@ -336,6 +359,12 @@ def is_qsfp28_media_type(media_type):
     else:
         return False
 
+def is_sfp_media_type(media_type):
+    if media_type in sfp_type_to_str:
+        return True
+    else:
+        return False
+
 def get_media_str(media_type):
     return media_type_to_str[media_type]
 
diff --git a/src/lag/nas_int_lag_cps.cpp b/src/lag/nas_int_lag_cps.cpp
index 9ab42fd..93c9018 100644
--- a/src/lag/nas_int_lag_cps.cpp
+++ b/src/lag/nas_int_lag_cps.cpp
@@ -343,23 +343,32 @@ static cps_api_return_code_t nas_cps_set_admin_status(cps_api_object_t obj,hal_i
 static cps_api_return_code_t nas_cps_add_port_to_lag(nas_lag_master_info_t *nas_lag_entry, hal_ifindex_t port_idx)
 {
     cps_api_return_code_t rc = cps_api_ret_code_OK;
-    char buff[MAX_CPS_MSG_BUFF];
-    if_master_info_t master_info = { nas_int_type_LAG, NAS_PORT_NONE, nas_lag_entry->ifindex};
     BASE_IF_MODE_t intf_mode = nas_intf_get_mode(port_idx);
+    /* Add to kernel only if port is not part of block list
+     * since for blocked port we don't want to add the port to lag in kernel to
+     * prevent hashing on that port in kernel
+     */
 
-    EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG", "Add Ports to Lag");
-
-    cps_api_object_t name_obj = cps_api_object_init(buff, sizeof(buff));
-    cps_api_object_attr_add_u32(name_obj,DELL_BASE_IF_CMN_IF_INTERFACES_INTERFACE_IF_INDEX, nas_lag_entry->ifindex);
-    cps_api_object_attr_add_u32(name_obj,DELL_IF_IF_INTERFACES_INTERFACE_MEMBER_PORTS, port_idx);
-
-    if(nas_os_add_port_to_lag(name_obj) != STD_ERR_OK) {
-        EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG",
-                   "Error adding port %d to lag  %d in the Kernel",
-                   port_idx,nas_lag_entry->ifindex);
-        return cps_api_ret_code_ERR;
+    bool block_port = true;
+    if(nas_lag_entry->block_port_list.find(port_idx) == nas_lag_entry->block_port_list.end()) {
+        block_port = false;
+        char buff[MAX_CPS_MSG_BUFF];
+        EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG", "Add Ports to Lag");
+
+        cps_api_object_t name_obj = cps_api_object_init(buff, sizeof(buff));
+        cps_api_object_attr_add_u32(name_obj,DELL_BASE_IF_CMN_IF_INTERFACES_INTERFACE_IF_INDEX, nas_lag_entry->ifindex);
+        cps_api_object_attr_add_u32(name_obj,DELL_IF_IF_INTERFACES_INTERFACE_MEMBER_PORTS, port_idx);
+
+        if(nas_os_add_port_to_lag(name_obj) != STD_ERR_OK) {
+             EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG",
+                        "Error adding port %d to lag  %d in the Kernel",
+                        port_idx,nas_lag_entry->ifindex);
+             return cps_api_ret_code_ERR;
+        }
     }
 
+    if_master_info_t master_info = { nas_int_type_LAG, NAS_PORT_NONE, nas_lag_entry->ifindex};
+
     if(!nas_intf_add_master(port_idx, master_info)){
         EV_LOGGING(INTERFACE,DEBUG,"NAS-LAG-MASTER","Failed to add master for lag memeber port");
     } else {
@@ -381,9 +390,14 @@ static cps_api_return_code_t nas_cps_add_port_to_lag(nas_lag_master_info_t *nas_
                     "Error inserting index %d in list", port_idx);
             return cps_api_ret_code_ERR;
         }
+
+        if (block_port && nas_lag_block_port(nas_lag_entry, port_idx, block_port) != STD_ERR_OK) {
+            EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG", "Error Block/unblock Port %d",port_idx);
+            return cps_api_ret_code_ERR;
+        }
     }
-    EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
-               "Add Ports to Lag Exit");
+
+    EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG","Add Ports to Lag Exit");
     return rc;
 }
 
@@ -423,10 +437,16 @@ static cps_api_return_code_t nas_cps_delete_port_from_lag(nas_lag_master_info_t
     }
 
     //NPU delete done, now delete from Kernel
-    if(nas_os_delete_port_from_lag(obj) != STD_ERR_OK) {
-        EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG",
-                    "Error deleting interface %d from OS", ifindex);
-        return cps_api_ret_code_ERR;
+
+    /*
+     * Check if the port is in block port list then it won't be added in the kernel
+     * in that case no need of deleting it from kernel
+     */
+    if(nas_lag_entry->block_port_list.find(ifindex) == nas_lag_entry->block_port_list.end()){
+        if(nas_os_delete_port_from_lag(obj) != STD_ERR_OK) {
+            EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG","Error deleting interface %d from OS", ifindex);
+            return cps_api_ret_code_ERR;
+        }
     }
 
     EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
@@ -461,16 +481,47 @@ static bool nas_lag_get_intf_ctrl_info(const char * name, interface_ctrl_t & i){
 }
 
 static cps_api_return_code_t cps_lag_update_ports(nas_lag_master_info_t  *nas_lag_entry,
-        nas_port_list_t &port_index_list,bool add_ports)
+        nas_port_list_t &port_index_list, cps_api_operation_types_t op)
 {
 
     EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG", "cps_lag_update_ports %d",
-               add_ports);
+               op);
+
+    /* If it's a SET operation we need to remove the ports that are not part of the new port list first */
+    if (op == cps_api_oper_SET) {
+        hal_ifindex_t port;
+        for(auto it = nas_lag_entry->port_list.begin(); it != nas_lag_entry->port_list.end();) {
+            if (port_index_list.find(*it) == port_index_list.end()) {
+                port = *it;
+                it++;
+                EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
+                           "Removing unneeded memberport %d", port);
+
+                if(nas_cps_delete_port_from_lag(nas_lag_entry, port) != cps_api_ret_code_OK) {
+                    EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG",
+                               "Error deleting unneeded memberport %d from  OS/NPU", port);
+                    return cps_api_ret_code_ERR;
+                }
+                nas_lag_entry->port_list.erase(port);
+                nas_lag_entry->port_oper_list.erase(port);
+
+                /* When LAG member port deleted, remove port from block list also */
+                if(nas_lag_entry->block_port_list.find(port) != nas_lag_entry->block_port_list.end()) {
+
+                    EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
+                                                "Delete uneeded memberport %d from Block list", port);
+                    nas_lag_entry->block_port_list.erase(port);
+                }
+            } else {
+                it++;
+            }
+        }
+    }
 
     for(auto it = port_index_list.begin() ; it != port_index_list.end() ; ++it){
 
-        if((nas_lag_entry->port_list.find(*it) == nas_lag_entry->port_list.end())
-                && (add_ports == true)) {
+        if(((op == cps_api_oper_CREATE) || (op == cps_api_oper_SET)) &&
+            (nas_lag_entry->port_list.find(*it) == nas_lag_entry->port_list.end())) {
 
             EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
                     "Received new port add %d", *it);
@@ -489,10 +540,8 @@ static cps_api_return_code_t cps_lag_update_ports(nas_lag_master_info_t  *nas_la
                 return cps_api_ret_code_ERR;
             }
 
-        }
-
-        if((nas_lag_entry->port_list.find(*it) != nas_lag_entry->port_list.end())
-                && (add_ports == false)) {
+        } else if((op == cps_api_oper_DELETE) &&
+            (nas_lag_entry->port_list.find(*it) != nas_lag_entry->port_list.end())) {
 
             EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
                        "Received new port delete %d", *it);
@@ -514,8 +563,9 @@ static cps_api_return_code_t cps_lag_update_ports(nas_lag_master_info_t  *nas_la
             }
 
         }
+
         EV_LOGGING(INTERFACE, NOTICE, "NAS-CPS-LAG", "CPS %s Port index %d to LAG %s operation successful",
-                        (add_ports) ? "Add" : "Remove", *it, nas_lag_entry->name);
+                        (op != cps_api_oper_DELETE) ? "Add" : "Remove", *it, nas_lag_entry->name);
     }
 
     return cps_api_ret_code_OK;
@@ -648,6 +698,44 @@ static cps_api_return_code_t nas_process_lag_block_ports(nas_lag_master_info_t
                        "Error Block/unblock Port %d",*it);
             return cps_api_ret_code_ERR;
         }
+
+        /*
+         * If blocked port is not in member port_list,
+         * it won't be added to kernel in the first place
+         */
+
+        if(nas_lag_entry->port_list.find(*it) == nas_lag_entry->port_list.end()){
+            continue;
+        }
+
+
+        cps_api_object_t lag_obj = cps_api_object_create();
+        if(!lag_obj){
+            EV_LOGGING(INTERFACE,ERR,"NAS-LAG","Failed to allocate memory to create obj to add/delete"
+                    "port to/from LAG");
+            return cps_api_ret_code_ERR;
+        }
+        cps_api_object_guard og(lag_obj);
+        cps_api_object_attr_add_u32(lag_obj,DELL_BASE_IF_CMN_IF_INTERFACES_INTERFACE_IF_INDEX,
+                                    nas_lag_entry->ifindex);
+        cps_api_object_attr_add_u32(lag_obj,DELL_IF_IF_INTERFACES_INTERFACE_MEMBER_PORTS,*it);
+
+        EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG", "Update block/unblock port %d,lag %d to kernel",
+                  *it,nas_lag_entry->ifindex);
+
+        if(port_state) {
+            if(nas_os_delete_port_from_lag(lag_obj) != STD_ERR_OK) {
+                EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG", "OS:Error deleting intf %d, mem idx %d",
+                                            nas_lag_entry->ifindex, *it);
+                return cps_api_ret_code_ERR;
+            }
+        } else {
+            if(nas_os_add_port_to_lag(lag_obj) != STD_ERR_OK) {
+                EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG", "OS:Error adding intf %d, mem idx %d",
+                                            nas_lag_entry->ifindex, *it);
+                return cps_api_ret_code_ERR;
+            }
+        }
     }
 
     return rc;
@@ -792,7 +880,7 @@ static cps_api_return_code_t nas_cps_set_lag(cps_api_object_t obj)
                 rc = nas_cps_set_admin_status(obj,lag_index,nas_lag_entry);
                 break;
             case DELL_IF_IF_INTERFACES_INTERFACE_MEMBER_PORTS:
-                port_list_attr =true;
+                port_list_attr = true;
                 if (cps_api_object_attr_len(it.attr) != 0) {
                    if(!nas_lag_process_member_ports(obj,port_list,it)){
                        return cps_api_ret_code_ERR;
@@ -828,21 +916,31 @@ static cps_api_return_code_t nas_cps_set_lag(cps_api_object_t obj)
     }
 
     if(unblock_port_list.size()) {
-        rc |= nas_process_lag_block_ports(nas_lag_entry, unblock_port_list, false);
+        rc = nas_process_lag_block_ports(nas_lag_entry, unblock_port_list, false);
+        if(rc == cps_api_ret_code_ERR){
+            EV_LOGGING(INTERFACE,ERR,"NAS-CPS-LAG", "Failed to process unblocked lag ports");
+            return rc;
+        }
     }
 
     if(block_port_list.size()) {
-        rc |= nas_process_lag_block_ports(nas_lag_entry, block_port_list, true);
+        rc = nas_process_lag_block_ports(nas_lag_entry, block_port_list, true);
+        if(rc == cps_api_ret_code_ERR){
+            EV_LOGGING(INTERFACE,ERR,"NAS-CPS-LAG", "Failed to process blocked lag ports");
+            return rc;
+        }
     }
 
-    rc = (rc == cps_api_ret_code_OK) ? cps_api_ret_code_OK : cps_api_ret_code_ERR;
 
     if(port_list_attr) {
         EV_LOGGING(INTERFACE, INFO, "NAS-CPS-LAG",
                 "Received %lu valid ports ", port_list.size());
         cps_api_operation_types_t op = cps_api_object_type_operation(cps_api_object_key(obj));
-        bool create = (op == cps_api_oper_CREATE )? true : false;
-        if(cps_lag_update_ports(nas_lag_entry, port_list,create) !=STD_ERR_OK)
+        /* If a CPS 'set' operation is used on an existing LAG and a port_list is provided, we will just
+         * insert the ports into the member port like, the same way it's performed in a CPS 'create'
+         * operation.
+         */
+        if(cps_lag_update_ports(nas_lag_entry, port_list,op) !=STD_ERR_OK)
         {
             EV_LOGGING(INTERFACE, ERR, "NAS-CPS-LAG",
                        "nas_process_cps_ports failure");
@@ -862,6 +960,7 @@ static cps_api_return_code_t nas_cps_set_lag(cps_api_object_t obj)
     return rc;
 }
 
+
 static void nas_pack_lag_if(cps_api_object_t obj, nas_lag_master_info_t *nas_lag_entry)
 {
     cps_api_key_from_attr_with_qual(cps_api_object_key(obj),BASE_IF_LAG_IF_INTERFACES_INTERFACE_OBJ,
diff --git a/src/nas_int_base_if.cpp b/src/nas_int_base_if.cpp
index b39b3dc..9fd9421 100644
--- a/src/nas_int_base_if.cpp
+++ b/src/nas_int_base_if.cpp
@@ -203,6 +203,12 @@ void nas_intf_container::nas_intf_dump_container(hal_ifindex_t ifx) noexcept {
 
 bool nas_intf_obj::nas_intf_obj_master_add(if_master_info_t m_info) {
 
+    for(auto itr = m_list.begin(); itr != m_list.end(); ++itr) {
+        if(itr->m_if_idx == m_info.m_if_idx) {
+            return false;
+        }
+    }
+
     //If LAG master, insert at front
     if(m_info.type == nas_int_type_LAG){
         m_list.push_front(m_info);
diff --git a/src/nas_int_ev_handlers.cpp b/src/nas_int_ev_handlers.cpp
index 070a995..f7e8d95 100644
--- a/src/nas_int_ev_handlers.cpp
+++ b/src/nas_int_ev_handlers.cpp
@@ -168,6 +168,26 @@ void nas_lag_ev_handler(cps_api_object_t obj) {
                 }
             }
         } else if (op == cps_api_oper_DELETE) {
+             nas_lag_master_info_t * lag_entry =NULL;
+             /*  delete the member from the lag */
+             lag_entry = nas_get_lag_node(bond_idx);
+             if(lag_entry == nullptr){
+                 EV_LOGGING(INTERFACE,INFO,"NAS-LAG","Failed to find lag entry with %d"
+                              "ifindex for delete operation",bond_idx);
+                 return;
+             }
+
+            /*
+             * For kernel notification to delete the member port, check if present in block list
+             * if it is in blocking list then we would have removed the port from kernel to prevent
+             * hashing to blocked port in kernel. In that case just continue and don't trigger
+             * mode change
+             */
+
+            if(lag_entry->block_port_list.find(mem_idx) != lag_entry->block_port_list.end()){
+                return;
+            }
+
             if(!nas_intf_del_master(mem_idx, master_info)){
                  EV_LOGGING(INTERFACE,DEBUG,"NAS-LAG",
                          "Failed to delete master for lag memeber port");
@@ -279,6 +299,17 @@ void nas_lag_ev_handler(cps_api_object_t obj) {
                         "ifindex for delete operation",bond_idx);
                 return;
             }
+
+            /*
+             * For kernel notification to delete the member port, check if present in block list
+             * if it is in blocking list then we would have removed the port from kernel to prevent
+             * hashing to blocked port in kernel. In that case just continue and let the port be
+             * still there in npu as part of lag
+             */
+            if(nas_lag_entry->block_port_list.find(mem_idx) != nas_lag_entry->block_port_list.end()){
+                return;
+            }
+
             if(nas_lag_member_delete(bond_idx, mem_idx) != STD_ERR_OK) {
                 EV_LOGGING(INTERFACE,INFO,"NAS-LAG",
                         "Failed to Delete member %s to the Lag %d", mem_name, bond_idx);
diff --git a/src/packet/packet_io.c b/src/packet/packet_io.c
index 8d8345a..7ec0fe8 100644
--- a/src/packet/packet_io.c
+++ b/src/packet/packet_io.c
@@ -55,7 +55,10 @@
 
 #define MAX_PKT_LEN        12000
 #define PKT_DBG_ERR        (1)
-#define PKT_DBG_DUMP       (1 << 1)
+#define PKT_DBG_DIR_IN     (1 << 1)
+#define PKT_DBG_DIR_OUT    (1 << 2)
+#define PKT_DBG_DIR_BOTH   (PKT_DBG_DIR_IN | PKT_DBG_DIR_OUT)
+#define PKT_DBG_DUMP(x)    ((x & PKT_DBG_DIR_IN) || (x & PKT_DBG_DIR_OUT))
 
 #define PKT_DEBUG(arg...)\
     do {\
@@ -88,14 +91,15 @@ void pkt_debug_counters(std_parsed_string_t handle) {
  */
 static pthread_t packet_io_thr;
 
-static void hal_packet_io_dump(uint8_t *buf, int len)
+static void hal_packet_io_dump(uint8_t *buf, int len, int pkt_dir)
 {
     int var_j, var_n;
 
-    if (pkt_debug == PKT_DBG_DUMP) {
+    if (pkt_dir & pkt_debug) {
         var_n = 0;
         if (buf != NULL) {
-            printf("[PKT_IO]: %s: Dumping Raw Pkt\r\n", __FUNCTION__);
+            printf("[PKT_IO][DIR-%s]: %s: Dumping Raw Pkt\r\n",
+                   ((pkt_dir == PKT_DBG_DIR_IN)? "IN":"OUT"),  __FUNCTION__);
             for (var_j = 0; var_j < len; var_j++) {
                 printf("0x%02x ", buf[var_j]);
                 if ((var_n != 0) && ((var_n + 1) % 16 == 0))
@@ -481,8 +485,8 @@ static t_std_error _cps_init ()
 static t_std_error dn_hal_packet_rx(uint8_t *pkt, uint32_t len, ndi_packet_attr_t *p_attr)
 {
     ++packets_rxed;
+    if (PKT_DBG_DUMP(pkt_debug)) hal_packet_io_dump(pkt, len, PKT_DBG_DIR_IN);
     PKT_DEBUG("[RX] on front npu %d port %d len %d",p_attr->npu_id,p_attr->rx_port,len);
-    if (pkt_debug == PKT_DBG_DUMP) hal_packet_io_dump(pkt, len);
 
     if (p_attr->trap_id == NDI_PACKET_TRAP_ID_SAMPLEPACKET)
         return _sflow_pkt_hdl (pkt, len, p_attr);
@@ -504,9 +508,7 @@ static void dn_hal_packet_tx(npu_id_t npu, npu_port_t port, void  *pkt, uint32_t
     ++packets_txed;
     ++packets_txed_to_pipeline_bypass;
 
-    PKT_DEBUG("[TX] for npu %d port %d len %d\r\n",npu,port,len);
-
-    if (pkt_debug == PKT_DBG_DUMP) hal_packet_io_dump(pkt, len);
+    if (PKT_DBG_DUMP(pkt_debug)) hal_packet_io_dump(pkt, len, PKT_DBG_DIR_OUT);
 
     attr.npu_id  = npu;
     attr.tx_port = port;
@@ -520,8 +522,9 @@ static void dn_hal_packet_tx(npu_id_t npu, npu_port_t port, void  *pkt, uint32_t
 
     if (ndi_packet_tx(pkt, len, &attr) != STD_ERR_OK) {
         PKT_DEBUG("[TX] Pkt txmission FAILED \r\n");
+
     } else {
-        PKT_DEBUG("[TX] Pkt txmission OK \r\n");
+        PKT_DEBUG("[TX] Pkt txmission OK for npu %d port %d len %d\r\n",npu,port,len);
     }
 }
 
@@ -538,7 +541,7 @@ void dn_hal_packet_tx_to_ingress_pipeline (void  *pkt, uint32_t len)
     ++packets_txed;
     ++packets_txed_to_pipeline_lookup;
 
-    if (pkt_debug == PKT_DBG_DUMP) hal_packet_io_dump(pkt, len);
+    if (PKT_DBG_DUMP(pkt_debug)) hal_packet_io_dump(pkt, len, PKT_DBG_DIR_OUT);
 
     attr.npu_id  = npu;
     attr.tx_port = 0;
@@ -549,14 +552,33 @@ void dn_hal_packet_tx_to_ingress_pipeline (void  *pkt, uint32_t len)
     if (ndi_packet_tx (pkt, len, &attr) != STD_ERR_OK) {
         PKT_DEBUG("[TX] Pkt txmission to ingress pipeline FAILED \r\n");
     } else {
-        PKT_DEBUG("[TX] Pkt txmission to ingress pipeline OK \r\n");
+        PKT_DEBUG("[TX] Pkt txmission to ingress pipeline OK for npu %d len %d\r\n",npu,len);
     }
 }
 
+void hal_packet_io_debug (bool flag, int pkt_dir) {
+    pkt_debug = flag;
+    if (pkt_debug && pkt_dir) pkt_debug = pkt_dir;
+}
+
 static void change_debug_flag_state(std_parsed_string_t handle) {
     if(std_parse_string_num_tokens(handle)==0) return;
     size_t ix = 0;
-    pkt_debug = strstr(std_parse_string_next(handle,&ix),"true")!=NULL ? 1 : 0;
+    bool flag = strstr(std_parse_string_next(handle,&ix),"true")!=NULL ? 1 : 0;
+
+    ix = 1;
+    int pkt_dir = 0;
+    const char *token = NULL;
+    if((token = std_parse_string_next(handle,&ix))!= NULL) {
+        if(!strcmp(token,"in")) {
+            pkt_dir = PKT_DBG_DIR_IN;
+        } else if(!strcmp(token,"out")) {
+            pkt_dir = PKT_DBG_DIR_OUT;
+        } else if(!strcmp(token,"both")) {
+            pkt_dir = PKT_DBG_DIR_BOTH;
+        }
+    }
+    hal_packet_io_debug (flag, pkt_dir);
 }
 
 
@@ -594,7 +616,7 @@ t_std_error hal_packet_io_init(void)
 
     ndi_packet_rx_register(dn_hal_packet_rx);
 
-    hal_shell_cmd_add("pkt-io-debug",change_debug_flag_state,"[true|false] Changes Debug flag state\nWarning: Enabling this will generate lots of information and may impact the performance");
+    hal_shell_cmd_add("pkt-io-debug",change_debug_flag_state,"[true|false] [in|out|both] Changes Debug flag state\nWarning: Enabling this will generate lots of information and may impact the performance");
     hal_shell_cmd_add("pkt-io-counters",pkt_debug_counters,"Displays Packet count");
 
     return STD_ERR_OK;
diff --git a/src/port/nas_int_logical_cps.cpp b/src/port/nas_int_logical_cps.cpp
index 987c9c8..df9a01c 100644
--- a/src/port/nas_int_logical_cps.cpp
+++ b/src/port/nas_int_logical_cps.cpp
@@ -1396,6 +1396,18 @@ static cps_api_return_code_t _intf_state_publish(npu_id_t npu_id, npu_port_t por
             cps_api_object_attr_add_u32(_intf_state,
                     DELL_IF_IF_INTERFACES_STATE_INTERFACE_AUTO_NEGOTIATION, _autoneg);
         }
+
+        ndi_intf_link_state_t link_state;
+        if (ndi_port_link_state_get(npu_id, port_id, &link_state) != STD_ERR_OK) {
+            EV_LOGGING(INTERFACE, ERR, "INT-UPDATE", "Failed to get link state for port %d",
+                       port_id);
+            return STD_ERR(INTERFACE, FAIL, 0);
+        }
+        IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t state =
+                        ndi_to_cps_oper_type(link_state.oper_status);
+        /*  Send event for oper status */
+        EV_LOGGING(INTERFACE, NOTICE, "INT-UPDATE", "publishing oper state for %s", ifname);
+        cps_api_object_attr_add_u32(_intf_state,IF_INTERFACES_STATE_INTERFACE_OPER_STATUS, state);
         cps_api_event_thread_publish(_intf_state);
     }
     return cps_api_ret_code_OK;
@@ -1531,11 +1543,18 @@ static cps_api_return_code_t _if_update(cps_api_object_t req_if, cps_api_object_
                        func->second.second, id, _port.if_name);
             ret = func->second.first(_port.npu_id,_port.port_id,req_if);
             if (ret!=cps_api_ret_code_OK) {
-                EV_LOGGING(INTERFACE,ERR,"NAS-IF-REG","Failed to set Attribute %s (%" PRId64 ") for interface  %s",
-                           func->second.second, id, _port.if_name);
-                if_rollback(rollback,_port);
-                cps_api_object_delete(rollback);
-                return ret;
+                if (!(if_set) && (id == DELL_IF_IF_INTERFACES_INTERFACE_SPEED ||
+                        id == DELL_IF_IF_INTERFACES_INTERFACE_FEC ||
+                        id == DELL_IF_IF_INTERFACES_INTERFACE_DUPLEX)){
+                    EV_LOGGING(INTERFACE,ERR,"NAS-IF-REG","Failed to set Attribute %s (%" PRId64 ") for interface  %s",
+                            func->second.second, id, _port.if_name);
+                } else {
+                    EV_LOGGING(INTERFACE,ERR,"NAS-IF-REG","Failed to set Attribute %s (%" PRId64 ") for interface  %s",
+                            func->second.second, id, _port.if_name);
+                    if_rollback(rollback,_port);
+                    cps_api_object_delete(rollback);
+                    return ret;
+                }
             } else {
                 const void *data = cps_api_object_get_data(prev, id);
                 if (NULL == data)
diff --git a/src/port/nas_int_port.cpp b/src/port/nas_int_port.cpp
index 35efded..0b54001 100644
--- a/src/port/nas_int_port.cpp
+++ b/src/port/nas_int_port.cpp
@@ -456,27 +456,33 @@ int nas_process_payload_and_form_packet (uint8_t *pkt_buf,
     struct timespec   ts_cur_pkt;
     struct timespec   ts_diff;
 
-    memset(&intf_ctrl, 0, sizeof(interface_ctrl_t));
-    intf_ctrl.q_type = HAL_INTF_INFO_FROM_IF;
-    intf_ctrl.if_index = p_nas_nflog_params->out_ifindex;
-
-    /* retrieve the VLAN id from interface index */
-    if ((dn_hal_get_interface_info(&intf_ctrl)) != STD_ERR_OK) {
-        EV_LOGGING(INTERFACE,ERR,"TAP-TX", "Processing payload failed. Invalid interface %d. ifInfo get failed",
-                   p_nas_nflog_params->out_ifindex);
-        return 0;
-    }
-
 //@@TODO handle for ipv6 ND
 
     /* reference arp header from nflog payload */
     p_arp_header = (arp_header_t *) p_nas_nflog_params->payload;
 
+    if (!(p_nas_nflog_params->payload_len))
+    {
+        /* return, if payload length is not valid */
+        return -1;
+    }
+
     if ((p_nas_nflog_params->hw_protocol != arp_protocol) ||
         (p_arp_header->ptype != ip_protocol))
     {
-        /* return 0, if its not IPv4 ARP */
-        return 0;
+        /* return, if its not IPv4 ARP */
+        return -1;
+    }
+
+    memset(&intf_ctrl, 0, sizeof(interface_ctrl_t));
+    intf_ctrl.q_type = HAL_INTF_INFO_FROM_IF;
+    intf_ctrl.if_index = p_nas_nflog_params->out_ifindex;
+
+    /* retrieve the VLAN id from interface index */
+    if ((dn_hal_get_interface_info(&intf_ctrl)) != STD_ERR_OK) {
+        EV_LOGGING(INTERFACE,ERR,"TAP-TX", "Processing payload failed. Invalid interface %d. ifInfo get failed",
+                   p_nas_nflog_params->out_ifindex);
+        return -1;
     }
 
     clock_gettime (CLOCK_MONOTONIC, &ts_cur_pkt);
@@ -576,7 +582,7 @@ void process_nflog_packets (evutil_socket_t fd, short evt, void *arg)
         if (pkt_len > 0) {
             nas_nflog_pkts_tx_to_ingress_pipeline++;
             g_vif_pkt_tx.tx_to_ingress_fun (g_vif_pkt_tx.tx_buf,pkt_len);
-        } else {
+        } else if (pkt_len == 0) {
             nas_nflog_pkts_tx_to_ingress_pipeline_dropped++;
         }
     }
@@ -988,30 +994,6 @@ static t_std_error update_if_reg_info(const char *name, npu_id_t npu, port_t por
     return STD_ERR_OK;
 }
 
-static void nas_send_port_oper_event (const char *name , IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t status) {
-
-
-    char buff[CPS_API_MIN_OBJ_LEN];
-    cps_api_object_t obj = cps_api_object_init(buff,sizeof(buff));
-
-
-    if (!cps_api_key_from_attr_with_qual(cps_api_object_key(obj),
-                DELL_BASE_IF_CMN_IF_INTERFACES_STATE_INTERFACE_OBJ,
-                cps_api_qualifier_OBSERVED)) {
-        EV_LOGGING(INTERFACE,ERR,"NAS-IF-REG",
-                   "Could not translate to logical interface key for intf %s" ,name);
-        return;
-    }
-
-    cps_api_set_key_data(obj,IF_INTERFACES_STATE_INTERFACE_NAME,
-                               cps_api_object_ATTR_T_BIN, name, strlen(name)+1);
-    cps_api_object_attr_add_u32(obj,IF_INTERFACES_STATE_INTERFACE_OPER_STATUS,
-            status);
-
-    EV_LOGGING(INTERFACE,NOTICE,"NAS-INTF-EVENT",
-               "Sending oper event notification for interface %s: oper_status %d", name, status);
-    hal_interface_send_event(obj);
-}
 
 t_std_error nas_int_update_npu_port(const char *name, npu_id_t npu, port_t port,
                                     bool connect)
@@ -1045,8 +1027,6 @@ t_std_error nas_int_update_npu_port(const char *name, npu_id_t npu, port_t port,
         IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_t state =
                         ndi_to_cps_oper_type(link_state.oper_status);
         _ports[npu][port]->set_link_state(state);
-        /*  Send event for oper status */
-        nas_send_port_oper_event (name, state);
     } else {
         _ports[npu][port]->set_link_state(IF_INTERFACES_STATE_INTERFACE_OPER_STATUS_DOWN);
         _ports[name].init();
@@ -1073,5 +1053,9 @@ t_std_error nas_int_update_npu_port(const char *name, npu_id_t npu, port_t port,
         return STD_ERR(INTERFACE, FAIL, 0);
     }
 
+    EV_LOGGING(INTERFACE, NOTICE, "INTF-UPDATE", "Interface %s is %s NPU %d PORT %d",
+               name, (connect ? "connected to" : "disconnected from"),
+               npu, port);
+
     return STD_ERR_OK;
 }
diff --git a/src/stats/nas_stats_if_cps.cpp b/src/stats/nas_stats_if_cps.cpp
index 1aab9c1..42ca6eb 100644
--- a/src/stats/nas_stats_if_cps.cpp
+++ b/src/stats/nas_stats_if_cps.cpp
@@ -41,6 +41,7 @@
 #include "ietf-interfaces.h"
 
 #include <time.h>
+#include <chrono>
 #include <vector>
 #include <unordered_map>
 #include <stdint.h>
@@ -158,6 +159,13 @@ static t_std_error populate_if_stat_ids(){
     return STD_ERR_OK;
 }
 
+static auto get_current_time() -> std::size_t{
+
+    auto time_stamp = std::chrono::steady_clock::now();
+    auto time_dur =  time_stamp.time_since_epoch();
+    auto time_now = time_dur.count() * std::chrono::system_clock::period::num / std::chrono::system_clock::period::den;
+    return time_now;
+}
 
 static bool get_stats(hal_ifindex_t ifindex, cps_api_object_list_t list){
 
@@ -195,7 +203,11 @@ static bool get_stats(hal_ifindex_t ifindex, cps_api_object_list_t list){
         cps_api_object_attr_add_u64(obj, if_stat_ids->at(ix), stat_values[ix]);
     }
 
-    cps_api_object_attr_add_u32(obj,DELL_BASE_IF_CMN_IF_INTERFACES_STATE_INTERFACE_STATISTICS_TIME_STAMP,time(NULL));
+    auto time_now = get_current_time();
+    cps_api_object_attr_add_u32(obj,DELL_BASE_IF_CMN_IF_INTERFACES_STATE_INTERFACE_STATISTICS_TIME_STAMP,time_now);
+    cps_api_object_attr_add_u32(obj,IF_INTERFACES_STATE_INTERFACE_IF_INDEX, ifindex);
+    if (strlen(intf_ctrl.if_name) != 0)
+        cps_api_object_attr_add(obj, IF_INTERFACES_STATE_INTERFACE_NAME, intf_ctrl.if_name, strlen(intf_ctrl.if_name) + 1);
 
     return true;
 }
@@ -219,8 +231,9 @@ static bool fill_cps_stats (cps_api_object_t obj, char *ptr, const char *name) {
     for(unsigned int ix = 0 ; ix < ARRAY_SIZE(stats_map) ; ++ix ){
        cps_api_object_attr_add_u64(obj, stats_map[ix].oid, stats_arr[stats_map[ix].index]);
     }
-    cps_api_object_attr_add_u32(obj,DELL_BASE_IF_CMN_IF_INTERFACES_STATE_INTERFACE_STATISTICS_TIME_STAMP,
-      time(NULL));
+
+    auto time_now =  get_current_time();
+    cps_api_object_attr_add_u32(obj,DELL_BASE_IF_CMN_IF_INTERFACES_STATE_INTERFACE_STATISTICS_TIME_STAMP,time_now);
     return ret;
 }
 
diff --git a/src/unit_test/nas_int_lag_unittest.cpp b/src/unit_test/nas_int_lag_unittest.cpp
index c10c3ee..1c19eda 100644
--- a/src/unit_test/nas_int_lag_unittest.cpp
+++ b/src/unit_test/nas_int_lag_unittest.cpp
@@ -338,6 +338,36 @@ TEST(std_lag_add_port_test, add_ports_to_lag)
     cps_api_transaction_close(&tr);
 }
 
+TEST(std_lag_add_port_test, add_ports_check_mac)
+{
+    cps_api_get_params_t gp;
+    cps_api_get_request_init(&gp);
+
+    cps_api_object_t obj = cps_api_object_list_create_obj_and_append(gp.filters);
+    ASSERT_TRUE(obj != nullptr);
+
+    cps_api_key_from_attr_with_qual(cps_api_object_key(obj),
+            DELL_BASE_IF_CMN_IF_INTERFACES_INTERFACE_OBJ, cps_api_qualifier_TARGET);
+
+    cps_api_object_attr_add(obj,IF_INTERFACES_INTERFACE_TYPE,
+        (const char *)IF_INTERFACE_TYPE_IANAIFT_IANA_INTERFACE_TYPE_IANAIFT_IEEE8023ADLAG,
+        sizeof(IF_INTERFACE_TYPE_IANAIFT_IANA_INTERFACE_TYPE_IANAIFT_IEEE8023ADLAG));
+
+    const char *lag_ifname = "bond1";
+    const char *test_mac_addr = "12:34:56:78:12:34";
+
+    cps_api_object_attr_add(obj,IF_INTERFACES_INTERFACE_NAME,lag_ifname,strlen(lag_ifname)+1);
+
+    if (cps_api_get(&gp)==cps_api_ret_code_OK) {
+        cps_api_object_t obj = cps_api_object_list_get(gp.list, 0);
+        cps_api_object_attr_t mac_attr = cps_api_get_key_data(obj, DELL_IF_IF_INTERFACES_INTERFACE_PHYS_ADDRESS);
+        const char *mac = (const char*) cps_api_object_attr_data_bin(mac_attr);
+        ASSERT_TRUE(strlen(mac) == strlen(test_mac_addr));
+        ASSERT_TRUE(strncmp(mac, test_mac_addr, strlen(test_mac_addr)) == 0);
+    }
+
+    cps_api_get_request_close(&gp);
+}
 
 TEST(std_lag_block_ports, block_ports_to_lag)
 {
diff --git a/src/unit_test/nas_int_vlan_filter_unittest.cpp b/src/unit_test/nas_int_vlan_filter_unittest.cpp
index 5ce3917..8e696d1 100644
--- a/src/unit_test/nas_int_vlan_filter_unittest.cpp
+++ b/src/unit_test/nas_int_vlan_filter_unittest.cpp
@@ -59,7 +59,7 @@ static uint32_t get_vlan_filter_value (void)
 
     if (cps_api_get(&gp)==cps_api_ret_code_OK) {
         cps_api_object_t obj = cps_api_object_list_get(gp.list, 0);
-        cps_api_object_attr_t filter_attr = cps_api_get_key_data(obj, 
+        cps_api_object_attr_t filter_attr = cps_api_get_key_data(obj,
                 DELL_BASE_IF_CMN_IF_INTERFACES_STATE_INTERFACE_VLAN_FILTER);
         if (filter_attr == nullptr)
         {
diff --git a/src/unit_test/nas_port_pkt_drop_test.py b/src/unit_test/nas_port_pkt_drop_test.py
index a0bd4bd..3fc48e5 100644
--- a/src/unit_test/nas_port_pkt_drop_test.py
+++ b/src/unit_test/nas_port_pkt_drop_test.py
@@ -1,11 +1,14 @@
 import subprocess
-import pytest
 import cps
 import cps_object
 
 test_intf = 'e101-002-0'
 test_vlan_id = 100
 
+PORT_ACCEPT_UNTAGGED = 1
+PORT_ACCEPT_TAGGED = 2
+PORT_ACCEPT_BOTH = 3
+
 def run_command(cmd, response = None):
     prt = subprocess.Popen(
         cmd,
@@ -14,7 +17,7 @@ def run_command(cmd, response = None):
         stderr=subprocess.STDOUT)
     if response is not None:
         for line in prt.stdout.readlines():
-            respose.append(line.rstrip())
+            response.append(line.rstrip())
     retval = prt.wait()
     return retval
 
@@ -31,26 +34,48 @@ def get_intf_tagging_mode(if_name):
         mode = None
     return mode
 
-def test_packet_drop_status():
+def test_default_drop_status():
+    # get untagged members under default vlan
+    untagged_intf_list = None
+    resp = []
+    assert run_command('cps_config_vlan.py --show --name br1', resp) == 0
+    for ret_line in resp:
+        tokens = ret_line.split('=')
+        if len(tokens) < 2:
+            continue
+        if tokens[0].strip() == 'dell-if/if/interfaces/interface/untagged-ports':
+            untagged_intf_list = tokens[1].strip().split(',')
+            break
+    if untagged_intf_list is None:
+        print 'No untagged member for default VLAN'
+        return
+    for intf in untagged_intf_list:
+        print 'Testing default drop status for interface %s' % intf
+        assert get_intf_tagging_mode(intf) == PORT_ACCEPT_UNTAGGED
+
+def test_vlan_packet_drop_status():
+    print 'Testing drop status change for interface %s with VLAN %d' % (test_intf, test_vlan_id)
     # create vlan, delete port from default vlan 1 and add untagged port to new vlan
     assert run_command('cps_config_vlan.py --add --id %d --vlantype 1' % test_vlan_id) == 0
     assert run_command('cps_config_vlan.py --delport --name br1 --port %s' % test_intf) == 0
     assert run_command('cps_config_vlan.py --addport --name br%d --port %s' % (test_vlan_id, test_intf)) == 0
-    # no drop enabled
-    assert get_intf_tagging_mode(test_intf) == 3
+    # tagged packets will be dropped for untagged member port
+    assert get_intf_tagging_mode(test_intf) == PORT_ACCEPT_UNTAGGED
     # delete untagged port from vlan
     assert run_command('cps_config_vlan.py --delport --name br%d --port %s' % (test_vlan_id, test_intf)) == 0
-    # untagged drop should be enabled
-    assert get_intf_tagging_mode(test_intf) == 2
+    # if port is not member of any vlan, it will not drop any kind of packets
+    assert get_intf_tagging_mode(test_intf) == PORT_ACCEPT_BOTH
     # add tagged port to vlan
     assert run_command('cps_config_vlan.py --addport --name br%d -t --port %s' % (test_vlan_id, test_intf)) == 0
-    # untagged drop status should not change
-    assert get_intf_tagging_mode(test_intf) == 2
+    # untagged packets will be dropped for tagged member port
+    assert get_intf_tagging_mode(test_intf) == PORT_ACCEPT_TAGGED
     assert run_command('cps_config_vlan.py --delport --name br%d -t --port %s' % (test_vlan_id, test_intf)) == 0
-    assert get_intf_tagging_mode(test_intf) == 2
+    # port is removed from vlan as tagged member, it will not drop any kind of packets
+    assert get_intf_tagging_mode(test_intf) == PORT_ACCEPT_BOTH
     # add port back to default vlan 1
     assert run_command('cps_config_vlan.py --addport --name br1 --port %s' % test_intf) == 0
-    assert get_intf_tagging_mode(test_intf) == 3
+    # port is restored to default status
+    assert get_intf_tagging_mode(test_intf) == PORT_ACCEPT_UNTAGGED
 
     # delete vlan
     assert run_command('cps_config_vlan.py --del --name br%d' % test_vlan_id) == 0
diff --git a/src/vlan/nas_int_bridge.cpp b/src/vlan/nas_int_bridge.cpp
index baa3b65..13cf342 100644
--- a/src/vlan/nas_int_bridge.cpp
+++ b/src/vlan/nas_int_bridge.cpp
@@ -186,7 +186,8 @@ hal_vlan_id_t vid, nas_port_mode_t port_mode, bool lag) {
         } else {
             if (!nas_is_non_npu_phy_port(p_iter_node->ifindex)) {
                 if (nas_add_or_del_port_to_vlan(p_iter_node->ndi_port.npu_id, vid,
-                                    &(p_iter_node->ndi_port), port_mode, false) != STD_ERR_OK) {
+                                    &(p_iter_node->ndi_port), port_mode, false, p_iter_node->ifindex)
+                        != STD_ERR_OK) {
                     EV_LOGGING(INTERFACE, ERR, "NAS-Vlan",
                       "Error deleting port %d with mode %d from vlan %d", p_iter_node->ifindex,
                        port_mode, vid);
diff --git a/src/vlan/nas_int_vlan.cpp b/src/vlan/nas_int_vlan.cpp
index dce8311..00c980d 100644
--- a/src/vlan/nas_int_vlan.cpp
+++ b/src/vlan/nas_int_vlan.cpp
@@ -40,6 +40,7 @@
 #include "hal_interface_common.h"
 #include "iana-if-type.h"
 #include "nas_if_utils.h"
+#include "nas_int_base_if.h"
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -153,9 +154,40 @@ void nas_handle_bridge_mac(nas_bridge_t *b_node)
     nas_cps_set_vlan_mac(name_obj, b_node);
 }
 
+static std::pair<bool, bool> nas_get_intf_packet_drop(hal_ifindex_t ifindex)
+{
+    int untagged_cnt = 0, tagged_cnt = 0;
+    auto master_cb = [&untagged_cnt, &tagged_cnt](if_master_info_t m_info) {
+        if (m_info.type != nas_int_type_VLAN) {
+            return;
+        }
+        if (m_info.mode == NAS_PORT_UNTAGGED || m_info.mode == NAS_PORT_HYBRID) {
+            untagged_cnt ++;
+        }
+        if (m_info.mode == NAS_PORT_TAGGED || m_info.mode == NAS_PORT_HYBRID) {
+            tagged_cnt ++;
+        }
+    };
+    nas_intf_master_callback(ifindex, master_cb);
+    EV_LOGGING(INTERFACE, INFO, "NAS-Vlan", "Interface with ifindex %d is untagged member of %d bridges and \
+tagged member of %d bridges",
+               ifindex, untagged_cnt, tagged_cnt);
+    bool drop_untag = true, drop_tag = true;
+    if (untagged_cnt > 0) {
+        drop_untag = false;
+    }
+    if (tagged_cnt > 0) {
+        drop_tag = false;
+    }
+    if (untagged_cnt == 0 && tagged_cnt == 0) {
+        drop_untag = drop_tag = false;
+    }
+    return std::make_pair(drop_untag, drop_tag);
+}
+
 t_std_error nas_add_or_del_port_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
                                         ndi_port_t *p_ndi_port, nas_port_mode_t port_mode,
-                                        bool add_port)
+                                        bool add_port, hal_ifindex_t ifindex)
 {
     ndi_port_list_t ndi_port_list;
     ndi_port_list_t *untag_list = NULL;
@@ -190,17 +222,25 @@ t_std_error nas_add_or_del_port_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
                         npu_id, p_ndi_port->npu_port);
             }
         }
+    }
 
-        EV_LOGGING(INTERFACE, INFO, "NAS-Vlan",
-                   "Updating packet drop: %s port <%d %d> discard untagged packet",
-                   (!add_port ? "enable" : "disable"),
-                   p_ndi_port->npu_id, p_ndi_port->npu_port);
-        if ((rc = ndi_port_set_packet_drop(npu_id, p_ndi_port->npu_port,
-                                           NDI_PORT_DROP_UNTAGGED, !add_port)) != STD_ERR_OK) {
-            EV_LOGGING(INTERFACE, ERR, "NAS-Port",
-                       "Error setting untagged drop for port <%d %d>",
-                       npu_id, p_ndi_port->npu_port);
-        }
+    auto pkt_drop = nas_get_intf_packet_drop(ifindex);
+    EV_LOGGING(INTERFACE, INFO, "NAS-Vlan",
+               "Updating packet drop for port <%d %d>: untagged - %s; tagged - %s",
+               p_ndi_port->npu_id, p_ndi_port->npu_port,
+               pkt_drop.first ? "drop" : "not drop",
+               pkt_drop.second ? "drop" : "not drop");
+    if ((rc = ndi_port_set_packet_drop(npu_id, p_ndi_port->npu_port,
+                                       NDI_PORT_DROP_UNTAGGED, pkt_drop.first)) != STD_ERR_OK) {
+        EV_LOGGING(INTERFACE, ERR, "NAS-Port",
+                   "Error setting untagged drop for port <%d %d>",
+                   npu_id, p_ndi_port->npu_port);
+    }
+    if ((rc = ndi_port_set_packet_drop(npu_id, p_ndi_port->npu_port,
+                                       NDI_PORT_DROP_TAGGED, pkt_drop.second)) != STD_ERR_OK) {
+        EV_LOGGING(INTERFACE, ERR, "NAS-Port",
+                   "Error setting tagged drop for port <%d %d>",
+                   npu_id, p_ndi_port->npu_port);
     }
 
     return STD_ERR_OK;
@@ -213,21 +253,45 @@ t_std_error nas_vlan_delete(npu_id_t npu_id, hal_vlan_id_t vlan_id)
 }
 
 static t_std_error nas_add_port_list_to_vlan(npu_id_t npu_id, hal_vlan_id_t vlan_id,
-                                               ndi_port_list_t *p_ndi_port_list,
-                                               bool tagged_port_list)
+                                const std::vector<std::pair<ndi_port_t, hal_ifindex_t>>& port_list,
+                                bool tagged_port_list)
 {
     t_std_error rc = STD_ERR_OK;
+    std::vector<ndi_port_t> tmp_port_list{};
+    for (auto& port_info: port_list) {
+        tmp_port_list.push_back(port_info.first);
+    }
+    ndi_port_list_t ndi_port_list{tmp_port_list.size(), tmp_port_list.data()};
     if (tagged_port_list) {
-        if ((rc = ndi_add_or_del_ports_to_vlan(npu_id, vlan_id,  p_ndi_port_list, NULL, true))
+        if ((rc = ndi_add_or_del_ports_to_vlan(npu_id, vlan_id,  &ndi_port_list, NULL, true))
                 != STD_ERR_OK)
             return rc;
     }
     else {
-        if ((rc = ndi_add_or_del_ports_to_vlan(npu_id, vlan_id, NULL, p_ndi_port_list, true))
+        if ((rc = ndi_add_or_del_ports_to_vlan(npu_id, vlan_id, NULL, &ndi_port_list, true))
              != STD_ERR_OK)
             return rc;
     }
-    return rc;
+    for (auto& port_info: port_list) {
+        npu_port_t port_id = port_info.first.npu_port;
+        auto pkt_drop = nas_get_intf_packet_drop(port_info.second);
+        EV_LOGGING(INTERFACE, INFO, "NAS-Port",
+                   "Updating packet drop for port <%d %d>: untagged - %s; tagged - %s",
+                   npu_id, port_id,
+                   pkt_drop.first ? "drop" : "not drop",
+                   pkt_drop.second ? "drop" : "not drop");
+        rc = ndi_port_set_packet_drop(npu_id, port_id, NDI_PORT_DROP_UNTAGGED, pkt_drop.first);
+        if (rc != STD_ERR_OK) {
+            EV_LOGGING(INTERFACE, INFO, "NAS-Port", "Failed to disable untagged drop for port <%d %d>",
+                       npu_id, port_id);
+        }
+        rc = ndi_port_set_packet_drop(npu_id, port_id, NDI_PORT_DROP_TAGGED, pkt_drop.second);
+        if (rc != STD_ERR_OK) {
+            EV_LOGGING(INTERFACE, INFO, "NAS-Port", "Failed to disable untagged drop for port <%d %d>",
+                       npu_id, port_id);
+        }
+    }
+    return STD_ERR_OK;
 }
 
 static t_std_error nas_vlan_get_intf_ctrl_info(hal_ifindex_t index, interface_ctrl_t &i){
@@ -247,18 +311,9 @@ static t_std_error nas_vlan_get_intf_ctrl_info(hal_ifindex_t index, interface_ct
 
 //@TODO change this to the vector..
 static void nas_copy_bridge_ports_to_ndi_port_list(std_dll_head *p_port_list,
-                                                   ndi_port_list_t *p_ndi_ports)
+                                    std::vector<std::pair<ndi_port_t, hal_ifindex_t>>& ndi_ports)
 {
     nas_list_node_t *p_link_iter_node = NULL, *p_temp_node = NULL;
-    ndi_port_t *p_port_t = NULL;
-    int count = 0;
-
-    if ((p_port_list == NULL) ||
-        (p_ndi_ports == NULL)) {
-        EV_LOGGING(INTERFACE, ERR, "NAS-Vlan",
-                   "Bridge port list or NDI port list is empty");
-        return;
-    }
 
     p_link_iter_node = nas_get_first_link_node(p_port_list);
 
@@ -267,10 +322,7 @@ static void nas_copy_bridge_ports_to_ndi_port_list(std_dll_head *p_port_list,
         EV_LOGGING(INTERFACE, DEBUG, "NAS-Vlan",
                     "Copying untagged port %d",
                      p_link_iter_node->ndi_port.npu_port);
-
-        p_port_t = &(p_ndi_ports->port_list[count++]);
-        p_port_t->npu_id = p_link_iter_node->ndi_port.npu_id;
-        p_port_t->npu_port = p_link_iter_node->ndi_port.npu_port;
+        ndi_ports.push_back(std::make_pair(p_link_iter_node->ndi_port, p_link_iter_node->ifindex));
 
         p_temp_node = p_link_iter_node;
         p_link_iter_node = nas_get_next_link_node(p_port_list, p_temp_node);
@@ -280,7 +332,6 @@ static void nas_copy_bridge_ports_to_ndi_port_list(std_dll_head *p_port_list,
 
 static t_std_error nas_add_all_ut_ports_to_vlan(nas_bridge_t *p_bridge_node)
 {
-    ndi_port_list_t ndi_port_list;
     size_t port_count = p_bridge_node->untagged_list.port_count;
     int npu_id = 0;
     nas_list_node_t *p_iter_node = NULL;
@@ -289,16 +340,13 @@ static t_std_error nas_add_all_ut_ports_to_vlan(nas_bridge_t *p_bridge_node)
 
     if (port_count != 0) {
         do {
-            ndi_port_list.port_list = (ndi_port_t *)malloc(sizeof (ndi_port_t) * port_count);
-            if (ndi_port_list.port_list==NULL) { err = STD_ERR(INTERFACE,FAIL,0) ; break; }
-
-            ndi_port_list.port_count = port_count;
+            std::vector<std::pair<ndi_port_t, hal_ifindex_t>> port_list{};
             nas_copy_bridge_ports_to_ndi_port_list(&p_bridge_node->untagged_list.port_list,
-                                                   &ndi_port_list);
+                                                   port_list);
 
             /* @todo : NPU_ID for bridge */
             if (nas_add_port_list_to_vlan(npu_id, p_bridge_node->vlan_id,
-                                      &ndi_port_list,
+                                      port_list,
                                       false) != STD_ERR_OK) {
                 err = (STD_ERR(INTERFACE,FAIL, 0));
                 break;
@@ -315,7 +363,6 @@ static t_std_error nas_add_all_ut_ports_to_vlan(nas_bridge_t *p_bridge_node)
             }
 
         } while(0);
-        free(ndi_port_list.port_list);
     }
     return err;
 }
@@ -383,7 +430,8 @@ t_std_error nas_process_list_for_vlan_del(nas_bridge_t *p_bridge,
                      p_link_node->ndi_port.npu_port);
 
         if (nas_add_or_del_port_to_vlan(p_link_node->ndi_port.npu_id, vlan_id,
-                                        &(p_link_node->ndi_port), port_mode, false) != STD_ERR_OK) {
+                                        &(p_link_node->ndi_port), port_mode, false, if_index)
+                != STD_ERR_OK) {
             EV_LOGGING(INTERFACE, ERR, "NAS-Vlan",
                         "Error deleting port %d from vlan %d",
                          if_index, vlan_id);
@@ -627,7 +675,8 @@ t_std_error nas_process_member_addition_to_vlan(nas_bridge_t *p_bridge_node, hal
         if(intf_type == nas_int_type_PORT) {
             //add tagged port to vlan
             if ((rc = nas_add_or_del_port_to_vlan(p_link_node->ndi_port.npu_id, p_bridge_node->vlan_id,
-                                                  &(p_link_node->ndi_port), port_mode, true)) != STD_ERR_OK) {
+                                                  &(p_link_node->ndi_port), port_mode, true, port_idx))
+                    != STD_ERR_OK) {
                 rc = (STD_ERR(INTERFACE,FAIL, rc));
                 return rc;
             }
diff --git a/src/vlan/nas_vlan_cps.cpp b/src/vlan/nas_vlan_cps.cpp
index 3482ff9..1435fec 100644
--- a/src/vlan/nas_vlan_cps.cpp
+++ b/src/vlan/nas_vlan_cps.cpp
@@ -117,7 +117,7 @@ static bool nas_vlan_process_port_association(hal_ifindex_t ifindex, npu_id_t np
                 return false;
             }
 
-            if((nas_add_or_del_port_to_vlan(npu,br_m->vlan_id,&ndi_port, it.mode,add)) != STD_ERR_OK){
+            if((nas_add_or_del_port_to_vlan(npu,br_m->vlan_id,&ndi_port, it.mode, add, ifindex)) != STD_ERR_OK){
                 EV_LOGGING(INTERFACE, ERR, "NAS-VLAN-MAP","Error adding port <%d %d> to NPU",
                         ndi_port.npu_id, ndi_port.npu_port);
                 nas_bridge_unlock();
@@ -1204,7 +1204,7 @@ static t_std_error nas_cps_add_port_to_vlan(nas_bridge_t *p_bridge, hal_ifindex_
 
     if ((p_link_node != NULL) && (!nas_is_non_npu_phy_port(port_idx))) {
         if((rc = nas_add_or_del_port_to_vlan(p_link_node->ndi_port.npu_id, vlan_id,
-                                      &(p_link_node->ndi_port), port_mode, true)) != STD_ERR_OK) {
+                                      &(p_link_node->ndi_port), port_mode, true, port_idx)) != STD_ERR_OK) {
             EV_LOGGING(INTERFACE, ERR, "NAS-Vlan",
                    "Error adding port <%d %d> to NPU",
                    p_link_node->ndi_port.npu_id, p_link_node->ndi_port.npu_port);
@@ -1300,7 +1300,8 @@ static t_std_error nas_cps_del_port_from_vlan(nas_bridge_t *p_bridge, nas_list_n
     if (!nas_is_non_npu_phy_port(p_link_node->ifindex)) {
     //delete the port from NPU if it is a NPU port
         if (nas_add_or_del_port_to_vlan(p_link_node->ndi_port.npu_id, p_bridge->vlan_id,
-                                    &(p_link_node->ndi_port), port_mode, false) != STD_ERR_OK) {
+                                    &(p_link_node->ndi_port), port_mode, false, p_link_node->ifindex)
+                != STD_ERR_OK) {
             EV_LOGGING(INTERFACE, ERR, "NAS-Vlan",
                   "Error deleting port %d with mode %d from vlan %d", p_link_node->ifindex,
                    port_mode, p_bridge->vlan_id);
